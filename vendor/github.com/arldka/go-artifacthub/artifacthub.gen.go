// Package artifacthub provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.13.3 DO NOT EDIT.
package artifacthub

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"

	"gopkg.in/yaml.v2"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
)

const (
	ApiKeyIdScopes     = "ApiKeyId.Scopes"
	ApiKeySecretScopes = "ApiKeySecret.Scopes"
)

// Defines values for ArgoTemplateSignatures.
const (
	ArgoTemplateSignaturesCosign ArgoTemplateSignatures = "cosign"
	ArgoTemplateSignaturesProv   ArgoTemplateSignatures = "prov"
)

// Defines values for AuthorizerAction.
const (
	AddOrganizationMember          AuthorizerAction = "addOrganizationMember"
	AddOrganizationRepository      AuthorizerAction = "addOrganizationRepository"
	All                            AuthorizerAction = "all"
	DeleteOrganization             AuthorizerAction = "deleteOrganization"
	DeleteOrganizationMember       AuthorizerAction = "deleteOrganizationMember"
	DeleteOrganizationRepository   AuthorizerAction = "deleteOrganizationRepository"
	GetAuthorizationPolicy         AuthorizerAction = "getAuthorizationPolicy"
	TransferOrganizationRepository AuthorizerAction = "transferOrganizationRepository"
	UpdateAuthorizationPolicy      AuthorizerAction = "updateAuthorizationPolicy"
	UpdateOrganization             AuthorizerAction = "updateOrganization"
	UpdateOrganizationRepository   AuthorizerAction = "updateOrganizationRepository"
)

// Defines values for ChangelogItemKind.
const (
	Added      ChangelogItemKind = "added"
	Changed    ChangelogItemKind = "changed"
	Deprecated ChangelogItemKind = "deprecated"
	Fixed      ChangelogItemKind = "fixed"
	Removed    ChangelogItemKind = "removed"
	Security   ChangelogItemKind = "security"
)

// Defines values for ContainerImageSignatures.
const (
	ContainerImageSignaturesCosign ContainerImageSignatures = "cosign"
	ContainerImageSignaturesProv   ContainerImageSignatures = "prov"
)

// Defines values for EventKindId.
const (
	EventKindIdN0 EventKindId = 0
	EventKindIdN1 EventKindId = 1
	EventKindIdN2 EventKindId = 2
	EventKindIdN4 EventKindId = 4
)

// Defines values for FalcoPackageSignatures.
const (
	FalcoPackageSignaturesCosign FalcoPackageSignatures = "cosign"
	FalcoPackageSignaturesProv   FalcoPackageSignatures = "prov"
)

// Defines values for GatekeeperPolicySignatures.
const (
	GatekeeperPolicySignaturesCosign GatekeeperPolicySignatures = "cosign"
	GatekeeperPolicySignaturesProv   GatekeeperPolicySignatures = "prov"
)

// Defines values for HelmPackageSignatures.
const (
	HelmPackageSignaturesCosign HelmPackageSignatures = "cosign"
	HelmPackageSignaturesProv   HelmPackageSignatures = "prov"
)

// Defines values for KeptnIntegrationsPackageSignatures.
const (
	KeptnIntegrationsPackageSignaturesCosign KeptnIntegrationsPackageSignatures = "cosign"
	KeptnIntegrationsPackageSignaturesProv   KeptnIntegrationsPackageSignatures = "prov"
)

// Defines values for KrewPluginsPackageSignatures.
const (
	KrewPluginsPackageSignaturesCosign KrewPluginsPackageSignatures = "cosign"
	KrewPluginsPackageSignaturesProv   KrewPluginsPackageSignatures = "prov"
)

// Defines values for KubeArmorPoliciesPackageSignatures.
const (
	KubeArmorPoliciesPackageSignaturesCosign KubeArmorPoliciesPackageSignatures = "cosign"
	KubeArmorPoliciesPackageSignaturesProv   KubeArmorPoliciesPackageSignatures = "prov"
)

// Defines values for KubewardenPoliciesPackageSignatures.
const (
	KubewardenPoliciesPackageSignaturesCosign KubewardenPoliciesPackageSignatures = "cosign"
	KubewardenPoliciesPackageSignaturesProv   KubewardenPoliciesPackageSignatures = "prov"
)

// Defines values for KyvernoPolicySignatures.
const (
	KyvernoPolicySignaturesCosign KyvernoPolicySignatures = "cosign"
	KyvernoPolicySignaturesProv   KyvernoPolicySignatures = "prov"
)

// Defines values for OLMPackageSignatures.
const (
	OLMPackageSignaturesCosign OLMPackageSignatures = "cosign"
	OLMPackageSignaturesProv   OLMPackageSignatures = "prov"
)

// Defines values for OPAPackageSignatures.
const (
	OPAPackageSignaturesCosign OPAPackageSignatures = "cosign"
	OPAPackageSignaturesProv   OPAPackageSignatures = "prov"
)

// Defines values for PackageSignatures.
const (
	PackageSignaturesCosign PackageSignatures = "cosign"
	PackageSignaturesProv   PackageSignatures = "prov"
)

// Defines values for PackageBaseSignatures.
const (
	PackageBaseSignaturesCosign PackageBaseSignatures = "cosign"
	PackageBaseSignaturesProv   PackageBaseSignatures = "prov"
)

// Defines values for PackageCategoryId.
const (
	PackageCategoryIdN1 PackageCategoryId = 1
	PackageCategoryIdN2 PackageCategoryId = 2
	PackageCategoryIdN3 PackageCategoryId = 3
	PackageCategoryIdN4 PackageCategoryId = 4
	PackageCategoryIdN5 PackageCategoryId = 5
	PackageCategoryIdN6 PackageCategoryId = 6
	PackageCategoryIdN7 PackageCategoryId = 7
	PackageCategoryIdN8 PackageCategoryId = 8
)

// Defines values for PackageSummarySignatures.
const (
	PackageSummarySignaturesCosign PackageSummarySignatures = "cosign"
	PackageSummarySignaturesProv   PackageSummarySignatures = "prov"
)

// Defines values for RepositoryKind.
const (
	RepositoryKindN0  RepositoryKind = 0
	RepositoryKindN1  RepositoryKind = 1
	RepositoryKindN10 RepositoryKind = 10
	RepositoryKindN11 RepositoryKind = 11
	RepositoryKindN12 RepositoryKind = 12
	RepositoryKindN13 RepositoryKind = 13
	RepositoryKindN14 RepositoryKind = 14
	RepositoryKindN15 RepositoryKind = 15
	RepositoryKindN16 RepositoryKind = 16
	RepositoryKindN2  RepositoryKind = 2
	RepositoryKindN3  RepositoryKind = 3
	RepositoryKindN4  RepositoryKind = 4
	RepositoryKindN5  RepositoryKind = 5
	RepositoryKindN6  RepositoryKind = 6
	RepositoryKindN7  RepositoryKind = 7
	RepositoryKindN8  RepositoryKind = 8
	RepositoryKindN9  RepositoryKind = 9
)

// Defines values for RepositoryKindParam.
const (
	RepositoryKindParamArgoTemplate        RepositoryKindParam = "argo-template"
	RepositoryKindParamBackstage           RepositoryKindParam = "backstage"
	RepositoryKindParamContainer           RepositoryKindParam = "container"
	RepositoryKindParamCoredns             RepositoryKindParam = "coredns"
	RepositoryKindParamFalco               RepositoryKindParam = "falco"
	RepositoryKindParamGatekeeper          RepositoryKindParam = "gatekeeper"
	RepositoryKindParamHelm                RepositoryKindParam = "helm"
	RepositoryKindParamHelmPlugin          RepositoryKindParam = "helm-plugin"
	RepositoryKindParamKedaScaler          RepositoryKindParam = "keda-scaler"
	RepositoryKindParamKeptn               RepositoryKindParam = "keptn"
	RepositoryKindParamKnativeClientPlugin RepositoryKindParam = "knative-client-plugin"
	RepositoryKindParamKrew                RepositoryKindParam = "krew"
	RepositoryKindParamKubearmor           RepositoryKindParam = "kubearmor"
	RepositoryKindParamKubewarden          RepositoryKindParam = "kubewarden"
	RepositoryKindParamKyverno             RepositoryKindParam = "kyverno"
	RepositoryKindParamOlm                 RepositoryKindParam = "olm"
	RepositoryKindParamOpa                 RepositoryKindParam = "opa"
	RepositoryKindParamTbaction            RepositoryKindParam = "tbaction"
	RepositoryKindParamTektonPipeline      RepositoryKindParam = "tekton-pipeline"
	RepositoryKindParamTektonTask          RepositoryKindParam = "tekton-task"
)

// Defines values for ResourceKindName.
const (
	OrganizationName ResourceKindName = "organizationName"
	RepositoryName   ResourceKindName = "repositoryName"
	RepositoryURL    ResourceKindName = "repositoryURL"
	UserAlias        ResourceKindName = "userAlias"
)

// Defines values for TektonPipelinePackageSignatures.
const (
	TektonPipelinePackageSignaturesCosign TektonPipelinePackageSignatures = "cosign"
	TektonPipelinePackageSignaturesProv   TektonPipelinePackageSignatures = "prov"
)

// Defines values for TektonTaskPackageSignatures.
const (
	Cosign TektonTaskPackageSignatures = "cosign"
	Prov   TektonTaskPackageSignatures = "prov"
)

// Defines values for SortParam.
const (
	SortParamRelevance SortParam = "relevance"
	SortParamStars     SortParam = "stars"
)

// Defines values for SearchPackagesParamsCategory.
const (
	SearchPackagesParamsCategoryN1 SearchPackagesParamsCategory = 1
	SearchPackagesParamsCategoryN2 SearchPackagesParamsCategory = 2
	SearchPackagesParamsCategoryN3 SearchPackagesParamsCategory = 3
	SearchPackagesParamsCategoryN4 SearchPackagesParamsCategory = 4
	SearchPackagesParamsCategoryN5 SearchPackagesParamsCategory = 5
	SearchPackagesParamsCategoryN6 SearchPackagesParamsCategory = 6
	SearchPackagesParamsCategoryN7 SearchPackagesParamsCategory = 7
	SearchPackagesParamsCategoryN8 SearchPackagesParamsCategory = 8
)

// Defines values for SearchPackagesParamsSort.
const (
	SearchPackagesParamsSortRelevance SearchPackagesParamsSort = "relevance"
	SearchPackagesParamsSortStars     SearchPackagesParamsSort = "stars"
)

// ArgoTemplate defines model for ArgoTemplate.
type ArgoTemplate struct {
	AllContainersImagesWhitelisted *bool   `json:"all_containers_images_whitelisted,omitempty"`
	AppVersion                     *string `json:"app_version,omitempty"`
	AvailableVersions              []struct {
		ContainsSecurityUpdates bool   `json:"contains_security_updates"`
		Prerelease              bool   `json:"prerelease"`
		Ts                      int    `json:"ts"`
		Version                 string `json:"version"`
	} `json:"available_versions"`
	Capabilities *string `json:"capabilities,omitempty"`

	// Category Package category:
	//   * `1` - AI / Machine learning
	//   * `2` - Database
	//   * `3` - Integration and delivery
	//   * `4` - Monitoring and logging
	//   * `5` - Networking
	//   * `6` - Security
	//   * `7` - Storage
	//   * `8` - Streaming and messaging
	Category *PackageCategoryId `json:"category,omitempty"`
	Channels *[]struct {
		Name    *string `json:"name,omitempty"`
		Version *string `json:"version,omitempty"`
	} `json:"channels,omitempty"`
	Cncf             *bool `json:"cncf"`
	ContainersImages *struct {
		Image       string  `json:"image"`
		Name        *string `json:"name,omitempty"`
		Whitelisted *bool   `json:"whitelisted,omitempty"`
	} `json:"containers_images,omitempty"`
	ContainsSecurityUpdates bool    `json:"contains_security_updates"`
	ContentUrl              *string `json:"content_url,omitempty"`
	Data                    *struct {
		Argoversion *string `json:"argo/version,omitempty"`
		Template    *string `json:"template,omitempty"`
	} `json:"data,omitempty"`
	DefaultChannel               *string            `json:"default_channel,omitempty"`
	Deprecated                   *bool              `json:"deprecated,omitempty"`
	Description                  *string            `json:"description,omitempty"`
	DisplayName                  *string            `json:"display_name,omitempty"`
	HasChangelog                 bool               `json:"has_changelog"`
	HasValuesSchema              bool               `json:"has_values_schema"`
	HomeUrl                      *string            `json:"home_url,omitempty"`
	IsOperator                   *bool              `json:"is_operator,omitempty"`
	Keywords                     *[]string          `json:"keywords,omitempty"`
	LatestVersion                string             `json:"latest_version"`
	License                      *string            `json:"license,omitempty"`
	Links                        *[]Link            `json:"links,omitempty"`
	LogoImageId                  *string            `json:"logo_image_id,omitempty"`
	LogoUrl                      *string            `json:"logo_url,omitempty"`
	Maintainers                  *[]Maintainer      `json:"maintainers,omitempty"`
	Name                         string             `json:"name"`
	NormalizedName               string             `json:"normalized_name"`
	Official                     *bool              `json:"official,omitempty"`
	PackageId                    openapi_types.UUID `json:"package_id"`
	Prerelease                   bool               `json:"prerelease"`
	ProductionOrganizationsCount *float32           `json:"production_organizations_count,omitempty"`
	Provider                     *string            `json:"provider,omitempty"`
	Readme                       *string            `json:"readme,omitempty"`
	Recommendations              *[]struct {
		Url *string `json:"url,omitempty"`
	} `json:"recommendations,omitempty"`
	Repository              RepositorySummary `json:"repository"`
	SecurityReportCreatedAt *int              `json:"security_report_created_at,omitempty"`
	SecurityReportSummary   *struct {
		Critical *float32 `json:"critical,omitempty"`
		High     *float32 `json:"high,omitempty"`
		Low      *float32 `json:"low,omitempty"`
		Medium   *float32 `json:"medium,omitempty"`
		Unknown  *float32 `json:"unknown,omitempty"`
	} `json:"security_report_summary,omitempty"`
	Signatures *[]ArgoTemplateSignatures `json:"signatures,omitempty"`
	Signed     *bool                     `json:"signed,omitempty"`
	Stats      *struct {
		Subscriptions int `json:"subscriptions"`
		Webhooks      int `json:"webhooks"`
	} `json:"stats,omitempty"`
	Ts      int    `json:"ts"`
	Version string `json:"version"`
}

// ArgoTemplateSignatures defines model for ArgoTemplate.Signatures.
type ArgoTemplateSignatures string

// AuthorizationPolicy defines model for AuthorizationPolicy.
type AuthorizationPolicy struct {
	AuthorizationEnabled bool                    `json:"authorization_enabled"`
	CustomPolicy         *string                 `json:"custom_policy,omitempty"`
	PolicyData           *map[string]interface{} `json:"policy_data,omitempty"`
	PredefinedPolicy     *string                 `json:"predefined_policy,omitempty"`
}

// AuthorizerAction Authorization policy action:
// * `all` - All actions
// * `addOrganizationMember` - Add member to organization
// * `addOrganizationRepository` - Add repository to organization
// * `deleteOrganization` - Delete organization
// * `deleteOrganizationMember` - Delete member from organization
// * `deleteOrganizationRepository` - Delete repository from organization
// * `getAuthorizationPolicy` - Get authorization policy
// * `transferOrganizationRepository` - Transfer repository from organization
// * `updateAuthorizationPolicy` - Update authorization policy
// * `updateOrganization` - Update organization
// * `updateOrganizationRepository` - Update repository from organization
type AuthorizerAction string

// BackstagePlugin defines model for BackstagePlugin.
type BackstagePlugin = Package

// ChangelogItemKind Types of changes:
//   - `added` - New features
//   - `changed` - Changes in existing functionality
//   - `deprecated` - Soon-to-be removed features
//   - `removed` - Removed features
//   - `fixed` - Any bug fixed
//   - `security` - In case of vulnerabilities
type ChangelogItemKind string

// ContainerImage defines model for ContainerImage.
type ContainerImage struct {
	AllContainersImagesWhitelisted *bool   `json:"all_containers_images_whitelisted,omitempty"`
	AppVersion                     *string `json:"app_version,omitempty"`
	AvailableVersions              []struct {
		ContainsSecurityUpdates bool   `json:"contains_security_updates"`
		Prerelease              bool   `json:"prerelease"`
		Ts                      int    `json:"ts"`
		Version                 string `json:"version"`
	} `json:"available_versions"`
	Capabilities *string `json:"capabilities,omitempty"`

	// Category Package category:
	//   * `1` - AI / Machine learning
	//   * `2` - Database
	//   * `3` - Integration and delivery
	//   * `4` - Monitoring and logging
	//   * `5` - Networking
	//   * `6` - Security
	//   * `7` - Storage
	//   * `8` - Streaming and messaging
	Category *PackageCategoryId `json:"category,omitempty"`
	Channels *[]struct {
		Name    *string `json:"name,omitempty"`
		Version *string `json:"version,omitempty"`
	} `json:"channels,omitempty"`
	Cncf             *bool `json:"cncf"`
	ContainersImages *struct {
		Image       string  `json:"image"`
		Name        *string `json:"name,omitempty"`
		Whitelisted *bool   `json:"whitelisted,omitempty"`
	} `json:"containers_images,omitempty"`
	ContainsSecurityUpdates bool    `json:"contains_security_updates"`
	ContentUrl              *string `json:"content_url,omitempty"`
	Data                    *struct {
		AlternativeLocations *[]string `json:"alternative_locations,omitempty"`
		Platforms            *[]string `json:"platforms,omitempty"`
	} `json:"data,omitempty"`
	DefaultChannel               *string            `json:"default_channel,omitempty"`
	Deprecated                   *bool              `json:"deprecated,omitempty"`
	Description                  *string            `json:"description,omitempty"`
	DisplayName                  *string            `json:"display_name,omitempty"`
	HasChangelog                 bool               `json:"has_changelog"`
	HasValuesSchema              bool               `json:"has_values_schema"`
	HomeUrl                      *string            `json:"home_url,omitempty"`
	IsOperator                   *bool              `json:"is_operator,omitempty"`
	Keywords                     *[]string          `json:"keywords,omitempty"`
	LatestVersion                string             `json:"latest_version"`
	License                      *string            `json:"license,omitempty"`
	Links                        *[]Link            `json:"links,omitempty"`
	LogoImageId                  *string            `json:"logo_image_id,omitempty"`
	LogoUrl                      *string            `json:"logo_url,omitempty"`
	Maintainers                  *[]Maintainer      `json:"maintainers,omitempty"`
	Name                         string             `json:"name"`
	NormalizedName               string             `json:"normalized_name"`
	Official                     *bool              `json:"official,omitempty"`
	PackageId                    openapi_types.UUID `json:"package_id"`
	Prerelease                   bool               `json:"prerelease"`
	ProductionOrganizationsCount *float32           `json:"production_organizations_count,omitempty"`
	Provider                     *string            `json:"provider,omitempty"`
	Readme                       *string            `json:"readme,omitempty"`
	Recommendations              *[]struct {
		Url *string `json:"url,omitempty"`
	} `json:"recommendations,omitempty"`
	Repository              RepositorySummary `json:"repository"`
	SecurityReportCreatedAt *int              `json:"security_report_created_at,omitempty"`
	SecurityReportSummary   *struct {
		Critical *float32 `json:"critical,omitempty"`
		High     *float32 `json:"high,omitempty"`
		Low      *float32 `json:"low,omitempty"`
		Medium   *float32 `json:"medium,omitempty"`
		Unknown  *float32 `json:"unknown,omitempty"`
	} `json:"security_report_summary,omitempty"`
	Signatures *[]ContainerImageSignatures `json:"signatures,omitempty"`
	Signed     *bool                       `json:"signed,omitempty"`
	Stats      *struct {
		Subscriptions int `json:"subscriptions"`
		Webhooks      int `json:"webhooks"`
	} `json:"stats,omitempty"`
	Ts      int    `json:"ts"`
	Version string `json:"version"`
}

// ContainerImageSignatures defines model for ContainerImage.Signatures.
type ContainerImageSignatures string

// CoreDNSPackage defines model for CoreDNSPackage.
type CoreDNSPackage = Package

// Error defines model for Error.
type Error struct {
	Message *string `json:"message,omitempty"`
}

// EventKindId Event kind:
//   - `0` - New package release
//   - `1` - Security alerts
//   - `2` - Repository tracking errors
//   - `4` - Repository scanning errors
type EventKindId int

// Facets defines model for Facets.
type Facets struct {
	FilterKey string `json:"filter_key"`
	Options   []struct {
		FilterKey *string `json:"filter_key,omitempty"`
		Id        string  `json:"id"`
		Name      string  `json:"name"`
		Total     int     `json:"total"`
	} `json:"options"`
	Title string `json:"title"`
}

// FalcoPackage defines model for FalcoPackage.
type FalcoPackage struct {
	AllContainersImagesWhitelisted *bool   `json:"all_containers_images_whitelisted,omitempty"`
	AppVersion                     *string `json:"app_version,omitempty"`
	AvailableVersions              []struct {
		ContainsSecurityUpdates bool   `json:"contains_security_updates"`
		Prerelease              bool   `json:"prerelease"`
		Ts                      int    `json:"ts"`
		Version                 string `json:"version"`
	} `json:"available_versions"`
	Capabilities *string `json:"capabilities,omitempty"`

	// Category Package category:
	//   * `1` - AI / Machine learning
	//   * `2` - Database
	//   * `3` - Integration and delivery
	//   * `4` - Monitoring and logging
	//   * `5` - Networking
	//   * `6` - Security
	//   * `7` - Storage
	//   * `8` - Streaming and messaging
	Category *PackageCategoryId `json:"category,omitempty"`
	Channels *[]struct {
		Name    *string `json:"name,omitempty"`
		Version *string `json:"version,omitempty"`
	} `json:"channels,omitempty"`
	Cncf             *bool `json:"cncf"`
	ContainersImages *struct {
		Image       string  `json:"image"`
		Name        *string `json:"name,omitempty"`
		Whitelisted *bool   `json:"whitelisted,omitempty"`
	} `json:"containers_images,omitempty"`
	ContainsSecurityUpdates bool    `json:"contains_security_updates"`
	ContentUrl              *string `json:"content_url,omitempty"`
	Data                    *struct {
		Rules *FalcoPackage_Data_Rules `json:"rules,omitempty"`
	} `json:"data,omitempty"`
	DefaultChannel               *string            `json:"default_channel,omitempty"`
	Deprecated                   *bool              `json:"deprecated,omitempty"`
	Description                  *string            `json:"description,omitempty"`
	DisplayName                  *string            `json:"display_name,omitempty"`
	HasChangelog                 bool               `json:"has_changelog"`
	HasValuesSchema              bool               `json:"has_values_schema"`
	HomeUrl                      *string            `json:"home_url,omitempty"`
	IsOperator                   *bool              `json:"is_operator,omitempty"`
	Keywords                     *[]string          `json:"keywords,omitempty"`
	LatestVersion                string             `json:"latest_version"`
	License                      *string            `json:"license,omitempty"`
	Links                        *[]Link            `json:"links,omitempty"`
	LogoImageId                  *string            `json:"logo_image_id,omitempty"`
	LogoUrl                      *string            `json:"logo_url,omitempty"`
	Maintainers                  *[]Maintainer      `json:"maintainers,omitempty"`
	Name                         string             `json:"name"`
	NormalizedName               string             `json:"normalized_name"`
	Official                     *bool              `json:"official,omitempty"`
	PackageId                    openapi_types.UUID `json:"package_id"`
	Prerelease                   bool               `json:"prerelease"`
	ProductionOrganizationsCount *float32           `json:"production_organizations_count,omitempty"`
	Provider                     *string            `json:"provider,omitempty"`
	Readme                       *string            `json:"readme,omitempty"`
	Recommendations              *[]struct {
		Url *string `json:"url,omitempty"`
	} `json:"recommendations,omitempty"`
	Repository              RepositorySummary `json:"repository"`
	SecurityReportCreatedAt *int              `json:"security_report_created_at,omitempty"`
	SecurityReportSummary   *struct {
		Critical *float32 `json:"critical,omitempty"`
		High     *float32 `json:"high,omitempty"`
		Low      *float32 `json:"low,omitempty"`
		Medium   *float32 `json:"medium,omitempty"`
		Unknown  *float32 `json:"unknown,omitempty"`
	} `json:"security_report_summary,omitempty"`
	Signatures *[]FalcoPackageSignatures `json:"signatures,omitempty"`
	Signed     *bool                     `json:"signed,omitempty"`
	Stats      *struct {
		Subscriptions int `json:"subscriptions"`
		Webhooks      int `json:"webhooks"`
	} `json:"stats,omitempty"`
	Ts      int    `json:"ts"`
	Version string `json:"version"`
}

// FalcoPackageDataRules0 defines model for .
type FalcoPackageDataRules0 = []struct {
	Name *string `json:"Name,omitempty"`
	Raw  *string `json:"Raw,omitempty"`
}

// FalcoPackageDataRules1 defines model for .
type FalcoPackageDataRules1 map[string]interface{}

// FalcoPackage_Data_Rules defines model for FalcoPackage.Data.Rules.
type FalcoPackage_Data_Rules struct {
	union json.RawMessage
}

// FalcoPackageSignatures defines model for FalcoPackage.Signatures.
type FalcoPackageSignatures string

// GatekeeperPolicy defines model for GatekeeperPolicy.
type GatekeeperPolicy struct {
	AllContainersImagesWhitelisted *bool   `json:"all_containers_images_whitelisted,omitempty"`
	AppVersion                     *string `json:"app_version,omitempty"`
	AvailableVersions              []struct {
		ContainsSecurityUpdates bool   `json:"contains_security_updates"`
		Prerelease              bool   `json:"prerelease"`
		Ts                      int    `json:"ts"`
		Version                 string `json:"version"`
	} `json:"available_versions"`
	Capabilities *string `json:"capabilities,omitempty"`

	// Category Package category:
	//   * `1` - AI / Machine learning
	//   * `2` - Database
	//   * `3` - Integration and delivery
	//   * `4` - Monitoring and logging
	//   * `5` - Networking
	//   * `6` - Security
	//   * `7` - Storage
	//   * `8` - Streaming and messaging
	Category *PackageCategoryId `json:"category,omitempty"`
	Channels *[]struct {
		Name    *string `json:"name,omitempty"`
		Version *string `json:"version,omitempty"`
	} `json:"channels,omitempty"`
	Cncf             *bool `json:"cncf"`
	ContainersImages *struct {
		Image       string  `json:"image"`
		Name        *string `json:"name,omitempty"`
		Whitelisted *bool   `json:"whitelisted,omitempty"`
	} `json:"containers_images,omitempty"`
	ContainsSecurityUpdates bool    `json:"contains_security_updates"`
	ContentUrl              *string `json:"content_url,omitempty"`
	Data                    *struct {
		Examples *[]struct {
			Cases *[]struct {
				Content *string `json:"content,omitempty"`
				Name    *string `json:"name,omitempty"`
				Path    *string `json:"path,omitempty"`
			} `json:"cases,omitempty"`
			Name *string `json:"name,omitempty"`
		} `json:"examples,omitempty"`
		Template *string `json:"template,omitempty"`
	} `json:"data,omitempty"`
	DefaultChannel               *string            `json:"default_channel,omitempty"`
	Deprecated                   *bool              `json:"deprecated,omitempty"`
	Description                  *string            `json:"description,omitempty"`
	DisplayName                  *string            `json:"display_name,omitempty"`
	HasChangelog                 bool               `json:"has_changelog"`
	HasValuesSchema              bool               `json:"has_values_schema"`
	HomeUrl                      *string            `json:"home_url,omitempty"`
	IsOperator                   *bool              `json:"is_operator,omitempty"`
	Keywords                     *[]string          `json:"keywords,omitempty"`
	LatestVersion                string             `json:"latest_version"`
	License                      *string            `json:"license,omitempty"`
	Links                        *[]Link            `json:"links,omitempty"`
	LogoImageId                  *string            `json:"logo_image_id,omitempty"`
	LogoUrl                      *string            `json:"logo_url,omitempty"`
	Maintainers                  *[]Maintainer      `json:"maintainers,omitempty"`
	Name                         string             `json:"name"`
	NormalizedName               string             `json:"normalized_name"`
	Official                     *bool              `json:"official,omitempty"`
	PackageId                    openapi_types.UUID `json:"package_id"`
	Prerelease                   bool               `json:"prerelease"`
	ProductionOrganizationsCount *float32           `json:"production_organizations_count,omitempty"`
	Provider                     *string            `json:"provider,omitempty"`
	Readme                       *string            `json:"readme,omitempty"`
	Recommendations              *[]struct {
		Url *string `json:"url,omitempty"`
	} `json:"recommendations,omitempty"`
	RelativePath            *string           `json:"relative_path,omitempty"`
	Repository              RepositorySummary `json:"repository"`
	SecurityReportCreatedAt *int              `json:"security_report_created_at,omitempty"`
	SecurityReportSummary   *struct {
		Critical *float32 `json:"critical,omitempty"`
		High     *float32 `json:"high,omitempty"`
		Low      *float32 `json:"low,omitempty"`
		Medium   *float32 `json:"medium,omitempty"`
		Unknown  *float32 `json:"unknown,omitempty"`
	} `json:"security_report_summary,omitempty"`
	Signatures *[]GatekeeperPolicySignatures `json:"signatures,omitempty"`
	Signed     *bool                         `json:"signed,omitempty"`
	Stats      *struct {
		Subscriptions int `json:"subscriptions"`
		Webhooks      int `json:"webhooks"`
	} `json:"stats,omitempty"`
	Ts      int    `json:"ts"`
	Version string `json:"version"`
}

// GatekeeperPolicySignatures defines model for GatekeeperPolicy.Signatures.
type GatekeeperPolicySignatures string

// HelmPackage defines model for HelmPackage.
type HelmPackage struct {
	AllContainersImagesWhitelisted *bool   `json:"all_containers_images_whitelisted,omitempty"`
	AppVersion                     *string `json:"app_version,omitempty"`
	AvailableVersions              []struct {
		ContainsSecurityUpdates bool   `json:"contains_security_updates"`
		Prerelease              bool   `json:"prerelease"`
		Ts                      int    `json:"ts"`
		Version                 string `json:"version"`
	} `json:"available_versions"`
	Capabilities *string `json:"capabilities,omitempty"`

	// Category Package category:
	//   * `1` - AI / Machine learning
	//   * `2` - Database
	//   * `3` - Integration and delivery
	//   * `4` - Monitoring and logging
	//   * `5` - Networking
	//   * `6` - Security
	//   * `7` - Storage
	//   * `8` - Streaming and messaging
	Category *PackageCategoryId `json:"category,omitempty"`
	Channels *[]struct {
		Name    *string `json:"name,omitempty"`
		Version *string `json:"version,omitempty"`
	} `json:"channels,omitempty"`
	Cncf             *bool `json:"cncf"`
	ContainersImages *struct {
		Image       string  `json:"image"`
		Name        *string `json:"name,omitempty"`
		Whitelisted *bool   `json:"whitelisted,omitempty"`
	} `json:"containers_images,omitempty"`
	ContainsSecurityUpdates bool    `json:"contains_security_updates"`
	ContentUrl              *string `json:"content_url,omitempty"`
	Crds                    *[]struct {
		Description string `json:"description"`
		DisplayName string `json:"displayName"`
		Kind        string `json:"kind"`
		Name        string `json:"name"`
		Version     string `json:"version"`
	} `json:"crds,omitempty"`
	CrdsExamples *[]map[string]interface{} `json:"crds_examples,omitempty"`
	Data         *struct {
		ApiVersion   *string `json:"apiVersion,omitempty"`
		Dependencies *struct {
			Name       string `json:"name"`
			Repository string `json:"repository"`
			Version    string `json:"version"`
		} `json:"dependencies,omitempty"`
		KubeVersion *string `json:"kubeVersion,omitempty"`
		Type        *string `json:"type,omitempty"`
	} `json:"data,omitempty"`
	DefaultChannel               *string            `json:"default_channel,omitempty"`
	Deprecated                   *bool              `json:"deprecated,omitempty"`
	Description                  *string            `json:"description,omitempty"`
	DisplayName                  *string            `json:"display_name,omitempty"`
	HasChangelog                 bool               `json:"has_changelog"`
	HasValuesSchema              bool               `json:"has_values_schema"`
	HomeUrl                      *string            `json:"home_url,omitempty"`
	IsOperator                   *bool              `json:"is_operator,omitempty"`
	Keywords                     *[]string          `json:"keywords,omitempty"`
	LatestVersion                string             `json:"latest_version"`
	License                      *string            `json:"license,omitempty"`
	Links                        *[]Link            `json:"links,omitempty"`
	LogoImageId                  *string            `json:"logo_image_id,omitempty"`
	LogoUrl                      *string            `json:"logo_url,omitempty"`
	Maintainers                  *[]Maintainer      `json:"maintainers,omitempty"`
	Name                         string             `json:"name"`
	NormalizedName               string             `json:"normalized_name"`
	Official                     *bool              `json:"official,omitempty"`
	PackageId                    openapi_types.UUID `json:"package_id"`
	Prerelease                   bool               `json:"prerelease"`
	ProductionOrganizationsCount *float32           `json:"production_organizations_count,omitempty"`
	Provider                     *string            `json:"provider,omitempty"`
	Readme                       *string            `json:"readme,omitempty"`
	Recommendations              *[]struct {
		Url *string `json:"url,omitempty"`
	} `json:"recommendations,omitempty"`
	Repository              RepositorySummary `json:"repository"`
	SecurityReportCreatedAt *int              `json:"security_report_created_at,omitempty"`
	SecurityReportSummary   *struct {
		Critical *float32 `json:"critical,omitempty"`
		High     *float32 `json:"high,omitempty"`
		Low      *float32 `json:"low,omitempty"`
		Medium   *float32 `json:"medium,omitempty"`
		Unknown  *float32 `json:"unknown,omitempty"`
	} `json:"security_report_summary,omitempty"`
	SignKey *struct {
		Fingerprint *string `json:"fingerprint,omitempty"`
		Url         *string `json:"url,omitempty"`
	} `json:"sign_key,omitempty"`
	Signatures *[]HelmPackageSignatures `json:"signatures,omitempty"`
	Signed     *bool                    `json:"signed,omitempty"`
	Stats      *struct {
		Subscriptions int `json:"subscriptions"`
		Webhooks      int `json:"webhooks"`
	} `json:"stats,omitempty"`
	Ts      int    `json:"ts"`
	Version string `json:"version"`
}

// HelmPackageSignatures defines model for HelmPackage.Signatures.
type HelmPackageSignatures string

// HelmPluginPackage defines model for HelmPluginPackage.
type HelmPluginPackage = Package

// KedaScalerPackage defines model for KedaScalerPackage.
type KedaScalerPackage = Package

// KeptnIntegrationsPackage defines model for KeptnIntegrationsPackage.
type KeptnIntegrationsPackage struct {
	AllContainersImagesWhitelisted *bool   `json:"all_containers_images_whitelisted,omitempty"`
	AppVersion                     *string `json:"app_version,omitempty"`
	AvailableVersions              []struct {
		ContainsSecurityUpdates bool   `json:"contains_security_updates"`
		Prerelease              bool   `json:"prerelease"`
		Ts                      int    `json:"ts"`
		Version                 string `json:"version"`
	} `json:"available_versions"`
	Capabilities *string `json:"capabilities,omitempty"`

	// Category Package category:
	//   * `1` - AI / Machine learning
	//   * `2` - Database
	//   * `3` - Integration and delivery
	//   * `4` - Monitoring and logging
	//   * `5` - Networking
	//   * `6` - Security
	//   * `7` - Storage
	//   * `8` - Streaming and messaging
	Category *PackageCategoryId `json:"category,omitempty"`
	Channels *[]struct {
		Name    *string `json:"name,omitempty"`
		Version *string `json:"version,omitempty"`
	} `json:"channels,omitempty"`
	Cncf             *bool `json:"cncf"`
	ContainersImages *struct {
		Image       string  `json:"image"`
		Name        *string `json:"name,omitempty"`
		Whitelisted *bool   `json:"whitelisted,omitempty"`
	} `json:"containers_images,omitempty"`
	ContainsSecurityUpdates bool    `json:"contains_security_updates"`
	ContentUrl              *string `json:"content_url,omitempty"`
	Data                    *struct {
		Keptnkind    *string `json:"keptn/kind,omitempty"`
		Keptnversion *string `json:"keptn/version,omitempty"`
	} `json:"data,omitempty"`
	DefaultChannel               *string            `json:"default_channel,omitempty"`
	Deprecated                   *bool              `json:"deprecated,omitempty"`
	Description                  *string            `json:"description,omitempty"`
	DisplayName                  *string            `json:"display_name,omitempty"`
	HasChangelog                 bool               `json:"has_changelog"`
	HasValuesSchema              bool               `json:"has_values_schema"`
	HomeUrl                      *string            `json:"home_url,omitempty"`
	IsOperator                   *bool              `json:"is_operator,omitempty"`
	Keywords                     *[]string          `json:"keywords,omitempty"`
	LatestVersion                string             `json:"latest_version"`
	License                      *string            `json:"license,omitempty"`
	Links                        *[]Link            `json:"links,omitempty"`
	LogoImageId                  *string            `json:"logo_image_id,omitempty"`
	LogoUrl                      *string            `json:"logo_url,omitempty"`
	Maintainers                  *[]Maintainer      `json:"maintainers,omitempty"`
	Name                         string             `json:"name"`
	NormalizedName               string             `json:"normalized_name"`
	Official                     *bool              `json:"official,omitempty"`
	PackageId                    openapi_types.UUID `json:"package_id"`
	Prerelease                   bool               `json:"prerelease"`
	ProductionOrganizationsCount *float32           `json:"production_organizations_count,omitempty"`
	Provider                     *string            `json:"provider,omitempty"`
	Readme                       *string            `json:"readme,omitempty"`
	Recommendations              *[]struct {
		Url *string `json:"url,omitempty"`
	} `json:"recommendations,omitempty"`
	Repository              RepositorySummary `json:"repository"`
	SecurityReportCreatedAt *int              `json:"security_report_created_at,omitempty"`
	SecurityReportSummary   *struct {
		Critical *float32 `json:"critical,omitempty"`
		High     *float32 `json:"high,omitempty"`
		Low      *float32 `json:"low,omitempty"`
		Medium   *float32 `json:"medium,omitempty"`
		Unknown  *float32 `json:"unknown,omitempty"`
	} `json:"security_report_summary,omitempty"`
	Signatures *[]KeptnIntegrationsPackageSignatures `json:"signatures,omitempty"`
	Signed     *bool                                 `json:"signed,omitempty"`
	Stats      *struct {
		Subscriptions int `json:"subscriptions"`
		Webhooks      int `json:"webhooks"`
	} `json:"stats,omitempty"`
	Ts      int    `json:"ts"`
	Version string `json:"version"`
}

// KeptnIntegrationsPackageSignatures defines model for KeptnIntegrationsPackage.Signatures.
type KeptnIntegrationsPackageSignatures string

// KnativeClientPluginsPackage defines model for KnativeClientPluginsPackage.
type KnativeClientPluginsPackage = Package

// KrewPluginsPackage defines model for KrewPluginsPackage.
type KrewPluginsPackage struct {
	AllContainersImagesWhitelisted *bool   `json:"all_containers_images_whitelisted,omitempty"`
	AppVersion                     *string `json:"app_version,omitempty"`
	AvailableVersions              []struct {
		ContainsSecurityUpdates bool   `json:"contains_security_updates"`
		Prerelease              bool   `json:"prerelease"`
		Ts                      int    `json:"ts"`
		Version                 string `json:"version"`
	} `json:"available_versions"`
	Capabilities *string `json:"capabilities,omitempty"`

	// Category Package category:
	//   * `1` - AI / Machine learning
	//   * `2` - Database
	//   * `3` - Integration and delivery
	//   * `4` - Monitoring and logging
	//   * `5` - Networking
	//   * `6` - Security
	//   * `7` - Storage
	//   * `8` - Streaming and messaging
	Category *PackageCategoryId `json:"category,omitempty"`
	Channels *[]struct {
		Name    *string `json:"name,omitempty"`
		Version *string `json:"version,omitempty"`
	} `json:"channels,omitempty"`
	Cncf             *bool `json:"cncf"`
	ContainersImages *struct {
		Image       string  `json:"image"`
		Name        *string `json:"name,omitempty"`
		Whitelisted *bool   `json:"whitelisted,omitempty"`
	} `json:"containers_images,omitempty"`
	ContainsSecurityUpdates bool    `json:"contains_security_updates"`
	ContentUrl              *string `json:"content_url,omitempty"`
	Data                    *struct {
		ManifestRaw *string   `json:"manifestRaw,omitempty"`
		Platforms   *[]string `json:"platforms,omitempty"`
	} `json:"data,omitempty"`
	DefaultChannel               *string            `json:"default_channel,omitempty"`
	Deprecated                   *bool              `json:"deprecated,omitempty"`
	Description                  *string            `json:"description,omitempty"`
	DisplayName                  *string            `json:"display_name,omitempty"`
	HasChangelog                 bool               `json:"has_changelog"`
	HasValuesSchema              bool               `json:"has_values_schema"`
	HomeUrl                      *string            `json:"home_url,omitempty"`
	IsOperator                   *bool              `json:"is_operator,omitempty"`
	Keywords                     *[]string          `json:"keywords,omitempty"`
	LatestVersion                string             `json:"latest_version"`
	License                      *string            `json:"license,omitempty"`
	Links                        *[]Link            `json:"links,omitempty"`
	LogoImageId                  *string            `json:"logo_image_id,omitempty"`
	LogoUrl                      *string            `json:"logo_url,omitempty"`
	Maintainers                  *[]Maintainer      `json:"maintainers,omitempty"`
	Name                         string             `json:"name"`
	NormalizedName               string             `json:"normalized_name"`
	Official                     *bool              `json:"official,omitempty"`
	PackageId                    openapi_types.UUID `json:"package_id"`
	Prerelease                   bool               `json:"prerelease"`
	ProductionOrganizationsCount *float32           `json:"production_organizations_count,omitempty"`
	Provider                     *string            `json:"provider,omitempty"`
	Readme                       *string            `json:"readme,omitempty"`
	Recommendations              *[]struct {
		Url *string `json:"url,omitempty"`
	} `json:"recommendations,omitempty"`
	Repository              RepositorySummary `json:"repository"`
	SecurityReportCreatedAt *int              `json:"security_report_created_at,omitempty"`
	SecurityReportSummary   *struct {
		Critical *float32 `json:"critical,omitempty"`
		High     *float32 `json:"high,omitempty"`
		Low      *float32 `json:"low,omitempty"`
		Medium   *float32 `json:"medium,omitempty"`
		Unknown  *float32 `json:"unknown,omitempty"`
	} `json:"security_report_summary,omitempty"`
	Signatures *[]KrewPluginsPackageSignatures `json:"signatures,omitempty"`
	Signed     *bool                           `json:"signed,omitempty"`
	Stats      *struct {
		Subscriptions int `json:"subscriptions"`
		Webhooks      int `json:"webhooks"`
	} `json:"stats,omitempty"`
	Ts      int    `json:"ts"`
	Version string `json:"version"`
}

// KrewPluginsPackageSignatures defines model for KrewPluginsPackage.Signatures.
type KrewPluginsPackageSignatures string

// KubeArmorPoliciesPackage defines model for KubeArmorPoliciesPackage.
type KubeArmorPoliciesPackage struct {
	AllContainersImagesWhitelisted *bool   `json:"all_containers_images_whitelisted,omitempty"`
	AppVersion                     *string `json:"app_version,omitempty"`
	AvailableVersions              []struct {
		ContainsSecurityUpdates bool   `json:"contains_security_updates"`
		Prerelease              bool   `json:"prerelease"`
		Ts                      int    `json:"ts"`
		Version                 string `json:"version"`
	} `json:"available_versions"`
	Capabilities *string `json:"capabilities,omitempty"`

	// Category Package category:
	//   * `1` - AI / Machine learning
	//   * `2` - Database
	//   * `3` - Integration and delivery
	//   * `4` - Monitoring and logging
	//   * `5` - Networking
	//   * `6` - Security
	//   * `7` - Storage
	//   * `8` - Streaming and messaging
	Category *PackageCategoryId `json:"category,omitempty"`
	Channels *[]struct {
		Name    *string `json:"name,omitempty"`
		Version *string `json:"version,omitempty"`
	} `json:"channels,omitempty"`
	Cncf             *bool `json:"cncf"`
	ContainersImages *struct {
		Image       string  `json:"image"`
		Name        *string `json:"name,omitempty"`
		Whitelisted *bool   `json:"whitelisted,omitempty"`
	} `json:"containers_images,omitempty"`
	ContainsSecurityUpdates bool    `json:"contains_security_updates"`
	ContentUrl              *string `json:"content_url,omitempty"`
	Data                    *struct {
		Policies *map[string]string `json:"policies,omitempty"`
	} `json:"data,omitempty"`
	DefaultChannel               *string            `json:"default_channel,omitempty"`
	Deprecated                   *bool              `json:"deprecated,omitempty"`
	Description                  *string            `json:"description,omitempty"`
	DisplayName                  *string            `json:"display_name,omitempty"`
	HasChangelog                 bool               `json:"has_changelog"`
	HasValuesSchema              bool               `json:"has_values_schema"`
	HomeUrl                      *string            `json:"home_url,omitempty"`
	IsOperator                   *bool              `json:"is_operator,omitempty"`
	Keywords                     *[]string          `json:"keywords,omitempty"`
	LatestVersion                string             `json:"latest_version"`
	License                      *string            `json:"license,omitempty"`
	Links                        *[]Link            `json:"links,omitempty"`
	LogoImageId                  *string            `json:"logo_image_id,omitempty"`
	LogoUrl                      *string            `json:"logo_url,omitempty"`
	Maintainers                  *[]Maintainer      `json:"maintainers,omitempty"`
	Name                         string             `json:"name"`
	NormalizedName               string             `json:"normalized_name"`
	Official                     *bool              `json:"official,omitempty"`
	PackageId                    openapi_types.UUID `json:"package_id"`
	Prerelease                   bool               `json:"prerelease"`
	ProductionOrganizationsCount *float32           `json:"production_organizations_count,omitempty"`
	Provider                     *string            `json:"provider,omitempty"`
	Readme                       *string            `json:"readme,omitempty"`
	Recommendations              *[]struct {
		Url *string `json:"url,omitempty"`
	} `json:"recommendations,omitempty"`
	Repository              RepositorySummary `json:"repository"`
	SecurityReportCreatedAt *int              `json:"security_report_created_at,omitempty"`
	SecurityReportSummary   *struct {
		Critical *float32 `json:"critical,omitempty"`
		High     *float32 `json:"high,omitempty"`
		Low      *float32 `json:"low,omitempty"`
		Medium   *float32 `json:"medium,omitempty"`
		Unknown  *float32 `json:"unknown,omitempty"`
	} `json:"security_report_summary,omitempty"`
	Signatures *[]KubeArmorPoliciesPackageSignatures `json:"signatures,omitempty"`
	Signed     *bool                                 `json:"signed,omitempty"`
	Stats      *struct {
		Subscriptions int `json:"subscriptions"`
		Webhooks      int `json:"webhooks"`
	} `json:"stats,omitempty"`
	Ts      int    `json:"ts"`
	Version string `json:"version"`
}

// KubeArmorPoliciesPackageSignatures defines model for KubeArmorPoliciesPackage.Signatures.
type KubeArmorPoliciesPackageSignatures string

// KubewardenPoliciesPackage defines model for KubewardenPoliciesPackage.
type KubewardenPoliciesPackage struct {
	AllContainersImagesWhitelisted *bool   `json:"all_containers_images_whitelisted,omitempty"`
	AppVersion                     *string `json:"app_version,omitempty"`
	AvailableVersions              []struct {
		ContainsSecurityUpdates bool   `json:"contains_security_updates"`
		Prerelease              bool   `json:"prerelease"`
		Ts                      int    `json:"ts"`
		Version                 string `json:"version"`
	} `json:"available_versions"`
	Capabilities *string `json:"capabilities,omitempty"`

	// Category Package category:
	//   * `1` - AI / Machine learning
	//   * `2` - Database
	//   * `3` - Integration and delivery
	//   * `4` - Monitoring and logging
	//   * `5` - Networking
	//   * `6` - Security
	//   * `7` - Storage
	//   * `8` - Streaming and messaging
	Category *PackageCategoryId `json:"category,omitempty"`
	Channels *[]struct {
		Name    *string `json:"name,omitempty"`
		Version *string `json:"version,omitempty"`
	} `json:"channels,omitempty"`
	Cncf             *bool `json:"cncf"`
	ContainersImages *struct {
		Image       string  `json:"image"`
		Name        *string `json:"name,omitempty"`
		Whitelisted *bool   `json:"whitelisted,omitempty"`
	} `json:"containers_images,omitempty"`
	ContainsSecurityUpdates bool    `json:"contains_security_updates"`
	ContentUrl              *string `json:"content_url,omitempty"`
	Data                    *struct {
		Kubewardenmutation  *string `json:"kubewarden/mutation,omitempty"`
		Kubewardenresources *string `json:"kubewarden/resources,omitempty"`
	} `json:"data,omitempty"`
	DefaultChannel               *string            `json:"default_channel,omitempty"`
	Deprecated                   *bool              `json:"deprecated,omitempty"`
	Description                  *string            `json:"description,omitempty"`
	DisplayName                  *string            `json:"display_name,omitempty"`
	HasChangelog                 bool               `json:"has_changelog"`
	HasValuesSchema              bool               `json:"has_values_schema"`
	HomeUrl                      *string            `json:"home_url,omitempty"`
	IsOperator                   *bool              `json:"is_operator,omitempty"`
	Keywords                     *[]string          `json:"keywords,omitempty"`
	LatestVersion                string             `json:"latest_version"`
	License                      *string            `json:"license,omitempty"`
	Links                        *[]Link            `json:"links,omitempty"`
	LogoImageId                  *string            `json:"logo_image_id,omitempty"`
	LogoUrl                      *string            `json:"logo_url,omitempty"`
	Maintainers                  *[]Maintainer      `json:"maintainers,omitempty"`
	Name                         string             `json:"name"`
	NormalizedName               string             `json:"normalized_name"`
	Official                     *bool              `json:"official,omitempty"`
	PackageId                    openapi_types.UUID `json:"package_id"`
	Prerelease                   bool               `json:"prerelease"`
	ProductionOrganizationsCount *float32           `json:"production_organizations_count,omitempty"`
	Provider                     *string            `json:"provider,omitempty"`
	Readme                       *string            `json:"readme,omitempty"`
	Recommendations              *[]struct {
		Url *string `json:"url,omitempty"`
	} `json:"recommendations,omitempty"`
	Repository              RepositorySummary `json:"repository"`
	SecurityReportCreatedAt *int              `json:"security_report_created_at,omitempty"`
	SecurityReportSummary   *struct {
		Critical *float32 `json:"critical,omitempty"`
		High     *float32 `json:"high,omitempty"`
		Low      *float32 `json:"low,omitempty"`
		Medium   *float32 `json:"medium,omitempty"`
		Unknown  *float32 `json:"unknown,omitempty"`
	} `json:"security_report_summary,omitempty"`
	Signatures *[]KubewardenPoliciesPackageSignatures `json:"signatures,omitempty"`
	Signed     *bool                                  `json:"signed,omitempty"`
	Stats      *struct {
		Subscriptions int `json:"subscriptions"`
		Webhooks      int `json:"webhooks"`
	} `json:"stats,omitempty"`
	Ts      int    `json:"ts"`
	Version string `json:"version"`
}

// KubewardenPoliciesPackageSignatures defines model for KubewardenPoliciesPackage.Signatures.
type KubewardenPoliciesPackageSignatures string

// KyvernoPolicy defines model for KyvernoPolicy.
type KyvernoPolicy struct {
	AllContainersImagesWhitelisted *bool   `json:"all_containers_images_whitelisted,omitempty"`
	AppVersion                     *string `json:"app_version,omitempty"`
	AvailableVersions              []struct {
		ContainsSecurityUpdates bool   `json:"contains_security_updates"`
		Prerelease              bool   `json:"prerelease"`
		Ts                      int    `json:"ts"`
		Version                 string `json:"version"`
	} `json:"available_versions"`
	Capabilities *string `json:"capabilities,omitempty"`

	// Category Package category:
	//   * `1` - AI / Machine learning
	//   * `2` - Database
	//   * `3` - Integration and delivery
	//   * `4` - Monitoring and logging
	//   * `5` - Networking
	//   * `6` - Security
	//   * `7` - Storage
	//   * `8` - Streaming and messaging
	Category *PackageCategoryId `json:"category,omitempty"`
	Channels *[]struct {
		Name    *string `json:"name,omitempty"`
		Version *string `json:"version,omitempty"`
	} `json:"channels,omitempty"`
	Cncf             *bool `json:"cncf"`
	ContainersImages *struct {
		Image       string  `json:"image"`
		Name        *string `json:"name,omitempty"`
		Whitelisted *bool   `json:"whitelisted,omitempty"`
	} `json:"containers_images,omitempty"`
	ContainsSecurityUpdates bool    `json:"contains_security_updates"`
	ContentUrl              *string `json:"content_url,omitempty"`
	Data                    *struct {
		Kyvernocategory          *string `json:"kyverno/category,omitempty"`
		KyvernokubernetesVersion *string `json:"kyverno/kubernetesVersion,omitempty"`
		Kyvernosubject           *string `json:"kyverno/subject,omitempty"`
		Kyvernoversion           *string `json:"kyverno/version,omitempty"`
		Policy                   *string `json:"policy,omitempty"`
	} `json:"data,omitempty"`
	DefaultChannel               *string            `json:"default_channel,omitempty"`
	Deprecated                   *bool              `json:"deprecated,omitempty"`
	Description                  *string            `json:"description,omitempty"`
	DisplayName                  *string            `json:"display_name,omitempty"`
	HasChangelog                 bool               `json:"has_changelog"`
	HasValuesSchema              bool               `json:"has_values_schema"`
	HomeUrl                      *string            `json:"home_url,omitempty"`
	IsOperator                   *bool              `json:"is_operator,omitempty"`
	Keywords                     *[]string          `json:"keywords,omitempty"`
	LatestVersion                string             `json:"latest_version"`
	License                      *string            `json:"license,omitempty"`
	Links                        *[]Link            `json:"links,omitempty"`
	LogoImageId                  *string            `json:"logo_image_id,omitempty"`
	LogoUrl                      *string            `json:"logo_url,omitempty"`
	Maintainers                  *[]Maintainer      `json:"maintainers,omitempty"`
	Name                         string             `json:"name"`
	NormalizedName               string             `json:"normalized_name"`
	Official                     *bool              `json:"official,omitempty"`
	PackageId                    openapi_types.UUID `json:"package_id"`
	Prerelease                   bool               `json:"prerelease"`
	ProductionOrganizationsCount *float32           `json:"production_organizations_count,omitempty"`
	Provider                     *string            `json:"provider,omitempty"`
	Readme                       *string            `json:"readme,omitempty"`
	Recommendations              *[]struct {
		Url *string `json:"url,omitempty"`
	} `json:"recommendations,omitempty"`
	RelativePath            *string           `json:"relative_path,omitempty"`
	Repository              RepositorySummary `json:"repository"`
	SecurityReportCreatedAt *int              `json:"security_report_created_at,omitempty"`
	SecurityReportSummary   *struct {
		Critical *float32 `json:"critical,omitempty"`
		High     *float32 `json:"high,omitempty"`
		Low      *float32 `json:"low,omitempty"`
		Medium   *float32 `json:"medium,omitempty"`
		Unknown  *float32 `json:"unknown,omitempty"`
	} `json:"security_report_summary,omitempty"`
	Signatures *[]KyvernoPolicySignatures `json:"signatures,omitempty"`
	Signed     *bool                      `json:"signed,omitempty"`
	Stats      *struct {
		Subscriptions int `json:"subscriptions"`
		Webhooks      int `json:"webhooks"`
	} `json:"stats,omitempty"`
	Ts      int    `json:"ts"`
	Version string `json:"version"`
}

// KyvernoPolicySignatures defines model for KyvernoPolicy.Signatures.
type KyvernoPolicySignatures string

// Link defines model for Link.
type Link struct {
	Name string `json:"name"`
	Url  string `json:"url"`
}

// Maintainer defines model for Maintainer.
type Maintainer struct {
	Email        string              `json:"email"`
	MaintainerId *openapi_types.UUID `json:"maintainer_id,omitempty"`
	Name         string              `json:"name"`
}

// Member defines model for Member.
type Member struct {
	Alias     string  `json:"alias"`
	Confirmed bool    `json:"confirmed"`
	FirstName *string `json:"first_name,omitempty"`
	LastName  *string `json:"last_name,omitempty"`
}

// OLMPackage defines model for OLMPackage.
type OLMPackage struct {
	AllContainersImagesWhitelisted *bool   `json:"all_containers_images_whitelisted,omitempty"`
	AppVersion                     *string `json:"app_version,omitempty"`
	AvailableVersions              []struct {
		ContainsSecurityUpdates bool   `json:"contains_security_updates"`
		Prerelease              bool   `json:"prerelease"`
		Ts                      int    `json:"ts"`
		Version                 string `json:"version"`
	} `json:"available_versions"`
	Capabilities *string `json:"capabilities,omitempty"`

	// Category Package category:
	//   * `1` - AI / Machine learning
	//   * `2` - Database
	//   * `3` - Integration and delivery
	//   * `4` - Monitoring and logging
	//   * `5` - Networking
	//   * `6` - Security
	//   * `7` - Storage
	//   * `8` - Streaming and messaging
	Category *PackageCategoryId `json:"category,omitempty"`
	Channels *[]struct {
		Name    *string `json:"name,omitempty"`
		Version *string `json:"version,omitempty"`
	} `json:"channels,omitempty"`
	Cncf             *bool `json:"cncf"`
	ContainersImages *struct {
		Image       string  `json:"image"`
		Name        *string `json:"name,omitempty"`
		Whitelisted *bool   `json:"whitelisted,omitempty"`
	} `json:"containers_images,omitempty"`
	ContainsSecurityUpdates bool    `json:"contains_security_updates"`
	ContentUrl              *string `json:"content_url,omitempty"`
	Crds                    *[]struct {
		Description string `json:"description"`
		DisplayName string `json:"displayName"`
		Kind        string `json:"kind"`
		Name        string `json:"name"`
		Version     string `json:"version"`
	} `json:"crds,omitempty"`
	CrdsExamples *[]map[string]interface{} `json:"crds_examples,omitempty"`
	Data         *struct {
		CustomResourcesDefinitions *[]struct {
			Description string `json:"description"`
			DisplayName string `json:"displayName"`
			Kind        string `json:"kind"`
			Name        string `json:"name"`
			Version     string `json:"version"`
		} `json:"customResourcesDefinitions,omitempty"`
		CustomResourcesDefinitionsExamples *string `json:"customResourcesDefinitionsExamples,omitempty"`
		IsGlobalOperator                   bool    `json:"isGlobalOperator"`
	} `json:"data,omitempty"`
	DefaultChannel               *string            `json:"default_channel,omitempty"`
	Deprecated                   *bool              `json:"deprecated,omitempty"`
	Description                  *string            `json:"description,omitempty"`
	DisplayName                  *string            `json:"display_name,omitempty"`
	HasChangelog                 bool               `json:"has_changelog"`
	HasValuesSchema              bool               `json:"has_values_schema"`
	HomeUrl                      *string            `json:"home_url,omitempty"`
	IsOperator                   *bool              `json:"is_operator,omitempty"`
	Keywords                     *[]string          `json:"keywords,omitempty"`
	LatestVersion                string             `json:"latest_version"`
	License                      *string            `json:"license,omitempty"`
	Links                        *[]Link            `json:"links,omitempty"`
	LogoImageId                  *string            `json:"logo_image_id,omitempty"`
	LogoUrl                      *string            `json:"logo_url,omitempty"`
	Maintainers                  *[]Maintainer      `json:"maintainers,omitempty"`
	Name                         string             `json:"name"`
	NormalizedName               string             `json:"normalized_name"`
	Official                     *bool              `json:"official,omitempty"`
	PackageId                    openapi_types.UUID `json:"package_id"`
	Prerelease                   bool               `json:"prerelease"`
	ProductionOrganizationsCount *float32           `json:"production_organizations_count,omitempty"`
	Provider                     *string            `json:"provider,omitempty"`
	Readme                       *string            `json:"readme,omitempty"`
	Recommendations              *[]struct {
		Url *string `json:"url,omitempty"`
	} `json:"recommendations,omitempty"`
	Repository              RepositorySummary `json:"repository"`
	SecurityReportCreatedAt *int              `json:"security_report_created_at,omitempty"`
	SecurityReportSummary   *struct {
		Critical *float32 `json:"critical,omitempty"`
		High     *float32 `json:"high,omitempty"`
		Low      *float32 `json:"low,omitempty"`
		Medium   *float32 `json:"medium,omitempty"`
		Unknown  *float32 `json:"unknown,omitempty"`
	} `json:"security_report_summary,omitempty"`
	Signatures *[]OLMPackageSignatures `json:"signatures,omitempty"`
	Signed     *bool                   `json:"signed,omitempty"`
	Stats      *struct {
		Subscriptions int `json:"subscriptions"`
		Webhooks      int `json:"webhooks"`
	} `json:"stats,omitempty"`
	Ts      int    `json:"ts"`
	Version string `json:"version"`
}

// OLMPackageSignatures defines model for OLMPackage.Signatures.
type OLMPackageSignatures string

// OPAPackage defines model for OPAPackage.
type OPAPackage struct {
	AllContainersImagesWhitelisted *bool   `json:"all_containers_images_whitelisted,omitempty"`
	AppVersion                     *string `json:"app_version,omitempty"`
	AvailableVersions              []struct {
		ContainsSecurityUpdates bool   `json:"contains_security_updates"`
		Prerelease              bool   `json:"prerelease"`
		Ts                      int    `json:"ts"`
		Version                 string `json:"version"`
	} `json:"available_versions"`
	Capabilities *string `json:"capabilities,omitempty"`

	// Category Package category:
	//   * `1` - AI / Machine learning
	//   * `2` - Database
	//   * `3` - Integration and delivery
	//   * `4` - Monitoring and logging
	//   * `5` - Networking
	//   * `6` - Security
	//   * `7` - Storage
	//   * `8` - Streaming and messaging
	Category *PackageCategoryId `json:"category,omitempty"`
	Channels *[]struct {
		Name    *string `json:"name,omitempty"`
		Version *string `json:"version,omitempty"`
	} `json:"channels,omitempty"`
	Cncf             *bool `json:"cncf"`
	ContainersImages *struct {
		Image       string  `json:"image"`
		Name        *string `json:"name,omitempty"`
		Whitelisted *bool   `json:"whitelisted,omitempty"`
	} `json:"containers_images,omitempty"`
	ContainsSecurityUpdates bool    `json:"contains_security_updates"`
	ContentUrl              *string `json:"content_url,omitempty"`
	Data                    *struct {
		Policies *map[string]string `json:"policies,omitempty"`
	} `json:"data,omitempty"`
	DefaultChannel               *string            `json:"default_channel,omitempty"`
	Deprecated                   *bool              `json:"deprecated,omitempty"`
	Description                  *string            `json:"description,omitempty"`
	DisplayName                  *string            `json:"display_name,omitempty"`
	HasChangelog                 bool               `json:"has_changelog"`
	HasValuesSchema              bool               `json:"has_values_schema"`
	HomeUrl                      *string            `json:"home_url,omitempty"`
	IsOperator                   *bool              `json:"is_operator,omitempty"`
	Keywords                     *[]string          `json:"keywords,omitempty"`
	LatestVersion                string             `json:"latest_version"`
	License                      *string            `json:"license,omitempty"`
	Links                        *[]Link            `json:"links,omitempty"`
	LogoImageId                  *string            `json:"logo_image_id,omitempty"`
	LogoUrl                      *string            `json:"logo_url,omitempty"`
	Maintainers                  *[]Maintainer      `json:"maintainers,omitempty"`
	Name                         string             `json:"name"`
	NormalizedName               string             `json:"normalized_name"`
	Official                     *bool              `json:"official,omitempty"`
	PackageId                    openapi_types.UUID `json:"package_id"`
	Prerelease                   bool               `json:"prerelease"`
	ProductionOrganizationsCount *float32           `json:"production_organizations_count,omitempty"`
	Provider                     *string            `json:"provider,omitempty"`
	Readme                       *string            `json:"readme,omitempty"`
	Recommendations              *[]struct {
		Url *string `json:"url,omitempty"`
	} `json:"recommendations,omitempty"`
	Repository              RepositorySummary `json:"repository"`
	SecurityReportCreatedAt *int              `json:"security_report_created_at,omitempty"`
	SecurityReportSummary   *struct {
		Critical *float32 `json:"critical,omitempty"`
		High     *float32 `json:"high,omitempty"`
		Low      *float32 `json:"low,omitempty"`
		Medium   *float32 `json:"medium,omitempty"`
		Unknown  *float32 `json:"unknown,omitempty"`
	} `json:"security_report_summary,omitempty"`
	Signatures *[]OPAPackageSignatures `json:"signatures,omitempty"`
	Signed     *bool                   `json:"signed,omitempty"`
	Stats      *struct {
		Subscriptions int `json:"subscriptions"`
		Webhooks      int `json:"webhooks"`
	} `json:"stats,omitempty"`
	Ts      int    `json:"ts"`
	Version string `json:"version"`
}

// OPAPackageSignatures defines model for OPAPackage.Signatures.
type OPAPackageSignatures string

// Organization defines model for Organization.
type Organization struct {
	Confirmed    bool    `json:"confirmed"`
	Description  *string `json:"description,omitempty"`
	DisplayName  *string `json:"display_name,omitempty"`
	HomeUrl      *string `json:"home_url,omitempty"`
	LogoImageId  *string `json:"logo_image_id,omitempty"`
	MembersCount int     `json:"members_count"`
	Name         string  `json:"name"`
}

// OrganizationSummary defines model for OrganizationSummary.
type OrganizationSummary struct {
	Description *string `json:"description,omitempty"`
	DisplayName *string `json:"display_name,omitempty"`
	HomeUrl     *string `json:"home_url,omitempty"`
	LogoImageId *string `json:"logo_image_id,omitempty"`
	Name        string  `json:"name"`
}

// Package defines model for Package.
type Package struct {
	AllContainersImagesWhitelisted *bool   `json:"all_containers_images_whitelisted,omitempty"`
	AppVersion                     *string `json:"app_version,omitempty"`
	AvailableVersions              []struct {
		ContainsSecurityUpdates bool   `json:"contains_security_updates"`
		Prerelease              bool   `json:"prerelease"`
		Ts                      int    `json:"ts"`
		Version                 string `json:"version"`
	} `json:"available_versions"`
	Capabilities *string `json:"capabilities,omitempty"`

	// Category Package category:
	//   * `1` - AI / Machine learning
	//   * `2` - Database
	//   * `3` - Integration and delivery
	//   * `4` - Monitoring and logging
	//   * `5` - Networking
	//   * `6` - Security
	//   * `7` - Storage
	//   * `8` - Streaming and messaging
	Category *PackageCategoryId `json:"category,omitempty"`
	Channels *[]struct {
		Name    *string `json:"name,omitempty"`
		Version *string `json:"version,omitempty"`
	} `json:"channels,omitempty"`
	Cncf             *bool `json:"cncf"`
	ContainersImages *struct {
		Image       string  `json:"image"`
		Name        *string `json:"name,omitempty"`
		Whitelisted *bool   `json:"whitelisted,omitempty"`
	} `json:"containers_images,omitempty"`
	ContainsSecurityUpdates      bool               `json:"contains_security_updates"`
	ContentUrl                   *string            `json:"content_url,omitempty"`
	DefaultChannel               *string            `json:"default_channel,omitempty"`
	Deprecated                   *bool              `json:"deprecated,omitempty"`
	Description                  *string            `json:"description,omitempty"`
	DisplayName                  *string            `json:"display_name,omitempty"`
	HasChangelog                 bool               `json:"has_changelog"`
	HasValuesSchema              bool               `json:"has_values_schema"`
	HomeUrl                      *string            `json:"home_url,omitempty"`
	IsOperator                   *bool              `json:"is_operator,omitempty"`
	Keywords                     *[]string          `json:"keywords,omitempty"`
	LatestVersion                string             `json:"latest_version"`
	License                      *string            `json:"license,omitempty"`
	Links                        *[]Link            `json:"links,omitempty"`
	LogoImageId                  *string            `json:"logo_image_id,omitempty"`
	LogoUrl                      *string            `json:"logo_url,omitempty"`
	Maintainers                  *[]Maintainer      `json:"maintainers,omitempty"`
	Name                         string             `json:"name"`
	NormalizedName               string             `json:"normalized_name"`
	Official                     *bool              `json:"official,omitempty"`
	PackageId                    openapi_types.UUID `json:"package_id"`
	Prerelease                   bool               `json:"prerelease"`
	ProductionOrganizationsCount *float32           `json:"production_organizations_count,omitempty"`
	Provider                     *string            `json:"provider,omitempty"`
	Readme                       *string            `json:"readme,omitempty"`
	Recommendations              *[]struct {
		Url *string `json:"url,omitempty"`
	} `json:"recommendations,omitempty"`
	Repository              RepositorySummary `json:"repository"`
	SecurityReportCreatedAt *int              `json:"security_report_created_at,omitempty"`
	SecurityReportSummary   *struct {
		Critical *float32 `json:"critical,omitempty"`
		High     *float32 `json:"high,omitempty"`
		Low      *float32 `json:"low,omitempty"`
		Medium   *float32 `json:"medium,omitempty"`
		Unknown  *float32 `json:"unknown,omitempty"`
	} `json:"security_report_summary,omitempty"`
	Signatures *[]PackageSignatures `json:"signatures,omitempty"`
	Signed     *bool                `json:"signed,omitempty"`
	Stats      *struct {
		Subscriptions int `json:"subscriptions"`
		Webhooks      int `json:"webhooks"`
	} `json:"stats,omitempty"`
	Ts      int    `json:"ts"`
	Version string `json:"version"`
}

// PackageSignatures defines model for Package.Signatures.
type PackageSignatures string

// PackageBase defines model for PackageBase.
type PackageBase struct {
	AllContainersImagesWhitelisted *bool              `json:"all_containers_images_whitelisted,omitempty"`
	AppVersion                     *string            `json:"app_version,omitempty"`
	Cncf                           *bool              `json:"cncf"`
	Deprecated                     *bool              `json:"deprecated,omitempty"`
	Description                    *string            `json:"description,omitempty"`
	DisplayName                    *string            `json:"display_name,omitempty"`
	License                        *string            `json:"license,omitempty"`
	LogoImageId                    *string            `json:"logo_image_id,omitempty"`
	Name                           string             `json:"name"`
	NormalizedName                 string             `json:"normalized_name"`
	Official                       *bool              `json:"official,omitempty"`
	PackageId                      openapi_types.UUID `json:"package_id"`
	ProductionOrganizationsCount   *float32           `json:"production_organizations_count,omitempty"`
	Repository                     RepositorySummary  `json:"repository"`
	SecurityReportSummary          *struct {
		Critical *float32 `json:"critical,omitempty"`
		High     *float32 `json:"high,omitempty"`
		Low      *float32 `json:"low,omitempty"`
		Medium   *float32 `json:"medium,omitempty"`
		Unknown  *float32 `json:"unknown,omitempty"`
	} `json:"security_report_summary,omitempty"`
	Signatures *[]PackageBaseSignatures `json:"signatures,omitempty"`
	Signed     *bool                    `json:"signed,omitempty"`
	Ts         int                      `json:"ts"`
	Version    string                   `json:"version"`
}

// PackageBaseSignatures defines model for PackageBase.Signatures.
type PackageBaseSignatures string

// PackageCategoryId Package category:
//   - `1` - AI / Machine learning
//   - `2` - Database
//   - `3` - Integration and delivery
//   - `4` - Monitoring and logging
//   - `5` - Networking
//   - `6` - Security
//   - `7` - Storage
//   - `8` - Streaming and messaging
type PackageCategoryId int

// PackageSummary defines model for PackageSummary.
type PackageSummary struct {
	AllContainersImagesWhitelisted *bool   `json:"all_containers_images_whitelisted,omitempty"`
	AppVersion                     *string `json:"app_version,omitempty"`

	// Category Package category:
	//   * `1` - AI / Machine learning
	//   * `2` - Database
	//   * `3` - Integration and delivery
	//   * `4` - Monitoring and logging
	//   * `5` - Networking
	//   * `6` - Security
	//   * `7` - Storage
	//   * `8` - Streaming and messaging
	Category                     *PackageCategoryId `json:"category,omitempty"`
	Cncf                         *bool              `json:"cncf"`
	Deprecated                   *bool              `json:"deprecated,omitempty"`
	Description                  *string            `json:"description,omitempty"`
	DisplayName                  *string            `json:"display_name,omitempty"`
	License                      *string            `json:"license,omitempty"`
	LogoImageId                  *string            `json:"logo_image_id,omitempty"`
	Name                         string             `json:"name"`
	NormalizedName               string             `json:"normalized_name"`
	Official                     *bool              `json:"official,omitempty"`
	PackageId                    openapi_types.UUID `json:"package_id"`
	ProductionOrganizationsCount *float32           `json:"production_organizations_count,omitempty"`
	Repository                   RepositorySummary  `json:"repository"`
	SecurityReportSummary        *struct {
		Critical *float32 `json:"critical,omitempty"`
		High     *float32 `json:"high,omitempty"`
		Low      *float32 `json:"low,omitempty"`
		Medium   *float32 `json:"medium,omitempty"`
		Unknown  *float32 `json:"unknown,omitempty"`
	} `json:"security_report_summary,omitempty"`
	Signatures *[]PackageSummarySignatures `json:"signatures,omitempty"`
	Signed     *bool                       `json:"signed,omitempty"`
	Stars      int                         `json:"stars"`
	Ts         int                         `json:"ts"`
	Version    string                      `json:"version"`
}

// PackageSummarySignatures defines model for PackageSummary.Signatures.
type PackageSummarySignatures string

// ProductionUsageOrganization defines model for ProductionUsageOrganization.
type ProductionUsageOrganization struct {
	DisplayName      *string `json:"display_name,omitempty"`
	HomeUrl          *string `json:"home_url,omitempty"`
	LogoImageId      *string `json:"logo_image_id,omitempty"`
	Name             string  `json:"name"`
	UsedInProduction *bool   `json:"used_in_production,omitempty"`
}

// Repository defines model for Repository.
type Repository struct {
	Branch *string `json:"branch,omitempty"`
	Cncf   *bool   `json:"cncf"`
	Data   *struct {
		Tags *[]struct {
			Mutable *bool  `json:"mutable,omitempty"`
			Name    string `json:"name"`
		} `json:"tags,omitempty"`
	} `json:"data,omitempty"`
	Digest      string  `json:"digest"`
	Disabled    bool    `json:"disabled"`
	DisplayName *string `json:"display_name,omitempty"`

	// Kind Repository kind:
	//   * `0` - Helm charts
	//   * `1` - Falco rules
	//   * `2` - OPA policies
	//   * `3` - OLM operators
	//   * `4` - Tinkerbell actions
	//   * `5` - Krew kubectl plugins
	//   * `6` - Helm plugins
	//   * `7` - Tekton tasks
	//   * `8` - KEDA scalers
	//   * `9` - Core DNS plugins
	//   * `10` - Keptn integrations
	//   * `11` - Tekton pipelines
	//   * `12` - Container images
	//   * `13` - Kubewarden policies
	//   * `14` - Gatekeeper policies
	//   * `15` - Kyverno policies
	//   * `16` - Knative client plugins
	//   * `17` - Backstage plugins
	//   * `18` - Argo templates
	//   * `19` - KubeArmor templates
	Kind                    RepositoryKind     `json:"kind"`
	LastScanningErrors      *string            `json:"last_scanning_errors,omitempty"`
	LastScanningTs          int                `json:"last_scanning_ts"`
	LastTrackingErrors      *string            `json:"last_tracking_errors,omitempty"`
	LastTrackingTs          int                `json:"last_tracking_ts"`
	Name                    string             `json:"name"`
	Official                bool               `json:"official"`
	OrganizationDisplayName *string            `json:"organization_display_name,omitempty"`
	OrganizationName        *string            `json:"organization_name,omitempty"`
	Private                 *bool              `json:"private,omitempty"`
	RepositoryId            openapi_types.UUID `json:"repository_id"`
	ScannerDisabled         bool               `json:"scanner_disabled"`
	Url                     string             `json:"url"`
	UserAlias               *string            `json:"user_alias,omitempty"`
	VerifiedPublisher       bool               `json:"verified_publisher"`
}

// RepositoryKind Repository kind:
//   - `0` - Helm charts
//   - `1` - Falco rules
//   - `2` - OPA policies
//   - `3` - OLM operators
//   - `4` - Tinkerbell actions
//   - `5` - Krew kubectl plugins
//   - `6` - Helm plugins
//   - `7` - Tekton tasks
//   - `8` - KEDA scalers
//   - `9` - Core DNS plugins
//   - `10` - Keptn integrations
//   - `11` - Tekton pipelines
//   - `12` - Container images
//   - `13` - Kubewarden policies
//   - `14` - Gatekeeper policies
//   - `15` - Kyverno policies
//   - `16` - Knative client plugins
//   - `17` - Backstage plugins
//   - `18` - Argo templates
//   - `19` - KubeArmor templates
type RepositoryKind int

// RepositoryKindParam Repository kind name:
// * `helm` - Helm charts
// * `falco` - Falco rules
// * `opa` - OPA policies
// * `olm` - OLM operators
// * `tbaction` - Tinkerbell actions
// * `krew` - Krew kubectl plugins
// * `helm-plugin` - Helm plugins
// * `tekton` - Tekton tasks
// * `keda-scaler` - KEDA scalers
// * `coredns` - Core DNS plugins
// * `keptn` - Keptn integrations
// * `tekton-pipeline` - Tekton pipelines
// * `container` - Container images
// * `kubewarden` - Kubewarden policies
// * `gatekeeper` - Gatekeeper policies
// * `kyverno` - Kyverno policies
// * `knative-client-plugin` - Knative client plugins
// * `backstage` - Backstage plugins
// * `argo-template` - Argo templates
// * `kubearmor` - KubeArmor policies
type RepositoryKindParam string

// RepositorySummary defines model for RepositorySummary.
type RepositorySummary struct {
	Cncf        *bool   `json:"cncf"`
	DisplayName *string `json:"display_name,omitempty"`

	// Kind Repository kind:
	//   * `0` - Helm charts
	//   * `1` - Falco rules
	//   * `2` - OPA policies
	//   * `3` - OLM operators
	//   * `4` - Tinkerbell actions
	//   * `5` - Krew kubectl plugins
	//   * `6` - Helm plugins
	//   * `7` - Tekton tasks
	//   * `8` - KEDA scalers
	//   * `9` - Core DNS plugins
	//   * `10` - Keptn integrations
	//   * `11` - Tekton pipelines
	//   * `12` - Container images
	//   * `13` - Kubewarden policies
	//   * `14` - Gatekeeper policies
	//   * `15` - Kyverno policies
	//   * `16` - Knative client plugins
	//   * `17` - Backstage plugins
	//   * `18` - Argo templates
	//   * `19` - KubeArmor templates
	Kind                    RepositoryKind     `json:"kind"`
	Name                    string             `json:"name"`
	Official                bool               `json:"official"`
	OrganizationDisplayName *string            `json:"organization_display_name,omitempty"`
	OrganizationName        *string            `json:"organization_name,omitempty"`
	Private                 *bool              `json:"private,omitempty"`
	RepositoryId            openapi_types.UUID `json:"repository_id"`
	ScannerDisabled         bool               `json:"scanner_disabled"`
	Url                     string             `json:"url"`
	UserAlias               *string            `json:"user_alias,omitempty"`
	VerifiedPublisher       bool               `json:"verified_publisher"`
}

// ResourceKindName Resource kind name:
//   - `repositoryName` - Repository name
//   - `repositoryURL` - Repository URL
//   - `organizationName` - Organization name
//   - `userAlias` - User alias
type ResourceKindName string

// TBActionPackage defines model for TBActionPackage.
type TBActionPackage = Package

// TektonPipelinePackage defines model for TektonPipelinePackage.
type TektonPipelinePackage struct {
	AllContainersImagesWhitelisted *bool   `json:"all_containers_images_whitelisted,omitempty"`
	AppVersion                     *string `json:"app_version,omitempty"`
	AvailableVersions              []struct {
		ContainsSecurityUpdates bool   `json:"contains_security_updates"`
		Prerelease              bool   `json:"prerelease"`
		Ts                      int    `json:"ts"`
		Version                 string `json:"version"`
	} `json:"available_versions"`
	Capabilities *string `json:"capabilities,omitempty"`

	// Category Package category:
	//   * `1` - AI / Machine learning
	//   * `2` - Database
	//   * `3` - Integration and delivery
	//   * `4` - Monitoring and logging
	//   * `5` - Networking
	//   * `6` - Security
	//   * `7` - Storage
	//   * `8` - Streaming and messaging
	Category *PackageCategoryId `json:"category,omitempty"`
	Channels *[]struct {
		Name    *string `json:"name,omitempty"`
		Version *string `json:"version,omitempty"`
	} `json:"channels,omitempty"`
	Cncf             *bool `json:"cncf"`
	ContainersImages *struct {
		Image       string  `json:"image"`
		Name        *string `json:"name,omitempty"`
		Whitelisted *bool   `json:"whitelisted,omitempty"`
	} `json:"containers_images,omitempty"`
	ContainsSecurityUpdates bool    `json:"contains_security_updates"`
	ContentUrl              *string `json:"content_url,omitempty"`
	Data                    *struct {
		Examples            *map[string]interface{} `json:"examples,omitempty"`
		ManifestRaw         *string                 `json:"manifestRaw,omitempty"`
		PipelinesMinVersion *string                 `json:"pipelines.minVersion,omitempty"`
		Platforms           *[]string               `json:"platforms,omitempty"`
		Tasks               *struct {
			Name     string    `json:"name"`
			RunAfter *[]string `json:"run_after,omitempty"`
		} `json:"tasks,omitempty"`
	} `json:"data,omitempty"`
	DefaultChannel               *string            `json:"default_channel,omitempty"`
	Deprecated                   *bool              `json:"deprecated,omitempty"`
	Description                  *string            `json:"description,omitempty"`
	DisplayName                  *string            `json:"display_name,omitempty"`
	HasChangelog                 bool               `json:"has_changelog"`
	HasValuesSchema              bool               `json:"has_values_schema"`
	HomeUrl                      *string            `json:"home_url,omitempty"`
	IsOperator                   *bool              `json:"is_operator,omitempty"`
	Keywords                     *[]string          `json:"keywords,omitempty"`
	LatestVersion                string             `json:"latest_version"`
	License                      *string            `json:"license,omitempty"`
	Links                        *[]Link            `json:"links,omitempty"`
	LogoImageId                  *string            `json:"logo_image_id,omitempty"`
	LogoUrl                      *string            `json:"logo_url,omitempty"`
	Maintainers                  *[]Maintainer      `json:"maintainers,omitempty"`
	Name                         string             `json:"name"`
	NormalizedName               string             `json:"normalized_name"`
	Official                     *bool              `json:"official,omitempty"`
	PackageId                    openapi_types.UUID `json:"package_id"`
	Prerelease                   bool               `json:"prerelease"`
	ProductionOrganizationsCount *float32           `json:"production_organizations_count,omitempty"`
	Provider                     *string            `json:"provider,omitempty"`
	Readme                       *string            `json:"readme,omitempty"`
	Recommendations              *[]struct {
		Url *string `json:"url,omitempty"`
	} `json:"recommendations,omitempty"`
	Repository              RepositorySummary `json:"repository"`
	SecurityReportCreatedAt *int              `json:"security_report_created_at,omitempty"`
	SecurityReportSummary   *struct {
		Critical *float32 `json:"critical,omitempty"`
		High     *float32 `json:"high,omitempty"`
		Low      *float32 `json:"low,omitempty"`
		Medium   *float32 `json:"medium,omitempty"`
		Unknown  *float32 `json:"unknown,omitempty"`
	} `json:"security_report_summary,omitempty"`
	Signatures *[]TektonPipelinePackageSignatures `json:"signatures,omitempty"`
	Signed     *bool                              `json:"signed,omitempty"`
	Stats      *struct {
		Subscriptions int `json:"subscriptions"`
		Webhooks      int `json:"webhooks"`
	} `json:"stats,omitempty"`
	Ts      int    `json:"ts"`
	Version string `json:"version"`
}

// TektonPipelinePackageSignatures defines model for TektonPipelinePackage.Signatures.
type TektonPipelinePackageSignatures string

// TektonTaskPackage defines model for TektonTaskPackage.
type TektonTaskPackage struct {
	AllContainersImagesWhitelisted *bool   `json:"all_containers_images_whitelisted,omitempty"`
	AppVersion                     *string `json:"app_version,omitempty"`
	AvailableVersions              []struct {
		ContainsSecurityUpdates bool   `json:"contains_security_updates"`
		Prerelease              bool   `json:"prerelease"`
		Ts                      int    `json:"ts"`
		Version                 string `json:"version"`
	} `json:"available_versions"`
	Capabilities *string `json:"capabilities,omitempty"`

	// Category Package category:
	//   * `1` - AI / Machine learning
	//   * `2` - Database
	//   * `3` - Integration and delivery
	//   * `4` - Monitoring and logging
	//   * `5` - Networking
	//   * `6` - Security
	//   * `7` - Storage
	//   * `8` - Streaming and messaging
	Category *PackageCategoryId `json:"category,omitempty"`
	Channels *[]struct {
		Name    *string `json:"name,omitempty"`
		Version *string `json:"version,omitempty"`
	} `json:"channels,omitempty"`
	Cncf             *bool `json:"cncf"`
	ContainersImages *struct {
		Image       string  `json:"image"`
		Name        *string `json:"name,omitempty"`
		Whitelisted *bool   `json:"whitelisted,omitempty"`
	} `json:"containers_images,omitempty"`
	ContainsSecurityUpdates bool    `json:"contains_security_updates"`
	ContentUrl              *string `json:"content_url,omitempty"`
	Data                    *struct {
		Examples            *map[string]interface{} `json:"examples,omitempty"`
		ManifestRaw         *string                 `json:"manifestRaw,omitempty"`
		PipelinesMinVersion *string                 `json:"pipelines.minVersion,omitempty"`
		Platforms           *[]string               `json:"platforms,omitempty"`
	} `json:"data,omitempty"`
	DefaultChannel               *string            `json:"default_channel,omitempty"`
	Deprecated                   *bool              `json:"deprecated,omitempty"`
	Description                  *string            `json:"description,omitempty"`
	DisplayName                  *string            `json:"display_name,omitempty"`
	HasChangelog                 bool               `json:"has_changelog"`
	HasValuesSchema              bool               `json:"has_values_schema"`
	HomeUrl                      *string            `json:"home_url,omitempty"`
	IsOperator                   *bool              `json:"is_operator,omitempty"`
	Keywords                     *[]string          `json:"keywords,omitempty"`
	LatestVersion                string             `json:"latest_version"`
	License                      *string            `json:"license,omitempty"`
	Links                        *[]Link            `json:"links,omitempty"`
	LogoImageId                  *string            `json:"logo_image_id,omitempty"`
	LogoUrl                      *string            `json:"logo_url,omitempty"`
	Maintainers                  *[]Maintainer      `json:"maintainers,omitempty"`
	Name                         string             `json:"name"`
	NormalizedName               string             `json:"normalized_name"`
	Official                     *bool              `json:"official,omitempty"`
	PackageId                    openapi_types.UUID `json:"package_id"`
	Prerelease                   bool               `json:"prerelease"`
	ProductionOrganizationsCount *float32           `json:"production_organizations_count,omitempty"`
	Provider                     *string            `json:"provider,omitempty"`
	Readme                       *string            `json:"readme,omitempty"`
	Recommendations              *[]struct {
		Url *string `json:"url,omitempty"`
	} `json:"recommendations,omitempty"`
	Repository              RepositorySummary `json:"repository"`
	SecurityReportCreatedAt *int              `json:"security_report_created_at,omitempty"`
	SecurityReportSummary   *struct {
		Critical *float32 `json:"critical,omitempty"`
		High     *float32 `json:"high,omitempty"`
		Low      *float32 `json:"low,omitempty"`
		Medium   *float32 `json:"medium,omitempty"`
		Unknown  *float32 `json:"unknown,omitempty"`
	} `json:"security_report_summary,omitempty"`
	Signatures *[]TektonTaskPackageSignatures `json:"signatures,omitempty"`
	Signed     *bool                          `json:"signed,omitempty"`
	Stats      *struct {
		Subscriptions int `json:"subscriptions"`
		Webhooks      int `json:"webhooks"`
	} `json:"stats,omitempty"`
	Ts      int    `json:"ts"`
	Version string `json:"version"`
}

// TektonTaskPackageSignatures defines model for TektonTaskPackage.Signatures.
type TektonTaskPackageSignatures string

// User defines model for User.
type User struct {
	Alias          string              `json:"alias"`
	Email          openapi_types.Email `json:"email"`
	FirstName      *string             `json:"first_name,omitempty"`
	LastName       *string             `json:"last_name,omitempty"`
	PasswordSet    bool                `json:"password_set"`
	ProfileImageId *string             `json:"profile_image_id,omitempty"`
	TfaEnabled     *bool               `json:"tfa_enabled,omitempty"`
}

// Webhook defines model for Webhook.
type Webhook struct {
	Active            bool                  `json:"active"`
	ContentType       *string               `json:"content_type,omitempty"`
	Description       *string               `json:"description,omitempty"`
	EventKinds        *[]EventKindId        `json:"event_kinds,omitempty"`
	LastNotifications []WebhookNotification `json:"last_notifications"`
	Name              string                `json:"name"`
	Packages          []PackageSummary      `json:"packages"`
	Secret            *string               `json:"secret,omitempty"`
	Template          *string               `json:"template,omitempty"`
	Url               string                `json:"url"`
	WebhookId         openapi_types.UUID    `json:"webhook_id"`
}

// WebhookNotification defines model for WebhookNotification.
type WebhookNotification struct {
	CreatedAt      int                `json:"created_at"`
	Error          *string            `json:"error,omitempty"`
	NotificationId openapi_types.UUID `json:"notification_id"`
	Processed      bool               `json:"processed"`
	ProcessedAt    int                `json:"processed_at"`
}

// WebhookSummary defines model for WebhookSummary.
type WebhookSummary struct {
	Active      bool           `json:"active"`
	ContentType *string        `json:"content_type,omitempty"`
	Description *string        `json:"description,omitempty"`
	EventKinds  *[]EventKindId `json:"event_kinds,omitempty"`
	Name        string         `json:"name"`
	Secret      *string        `json:"secret,omitempty"`
	Template    *string        `json:"template,omitempty"`
	Url         string         `json:"url"`
}

// WebhookSummaryWithPackages defines model for WebhookSummaryWithPackages.
type WebhookSummaryWithPackages struct {
	Active      bool          `json:"active"`
	ContentType *string       `json:"content_type,omitempty"`
	Description *string       `json:"description,omitempty"`
	EventKinds  []EventKindId `json:"event_kinds"`
	Name        string        `json:"name"`
	Packages    []struct {
		PackageId openapi_types.UUID `json:"package_id"`
	} `json:"packages"`
	Secret   *string `json:"secret,omitempty"`
	Template *string `json:"template,omitempty"`
	Url      string  `json:"url"`
}

// WebhookTest defines model for WebhookTest.
type WebhookTest struct {
	ContentType *string       `json:"content_type,omitempty"`
	EventKinds  []EventKindId `json:"event_kinds"`
	Template    *string       `json:"template,omitempty"`
	Url         string        `json:"url"`
}

// CNCFParam defines model for CNCFParam.
type CNCFParam = bool

// CapabilitiesListParam defines model for CapabilitiesListParam.
type CapabilitiesListParam = []string

// DeprecatedParam defines model for DeprecatedParam.
type DeprecatedParam = bool

// EventKindParam Event kind:
//   - `0` - New package release
//   - `1` - Security alerts
//   - `2` - Repository tracking errors
//   - `4` - Repository scanning errors
type EventKindParam = EventKindId

// FacetsParam defines model for FacetsParam.
type FacetsParam = bool

// LicensesListParam defines model for LicensesListParam.
type LicensesListParam = []string

// LimitParam defines model for LimitParam.
type LimitParam = int

// OfficialParam defines model for OfficialParam.
type OfficialParam = bool

// OffsetParam defines model for OffsetParam.
type OffsetParam = int

// OperatorsParam defines model for OperatorsParam.
type OperatorsParam = bool

// OptOutIDParam defines model for OptOutIDParam.
type OptOutIDParam = openapi_types.UUID

// OrgNameParam defines model for OrgNameParam.
type OrgNameParam = string

// OrgNameToParam defines model for OrgNameToParam.
type OrgNameToParam = string

// OrgsListParam defines model for OrgsListParam.
type OrgsListParam = []string

// PackageCategoryListParam defines model for PackageCategoryListParam.
type PackageCategoryListParam = []int

// PackageIDParam defines model for PackageIDParam.
type PackageIDParam = openapi_types.UUID

// PackageIDQueryParam defines model for PackageIDQueryParam.
type PackageIDQueryParam = openapi_types.UUID

// PackageNameParam defines model for PackageNameParam.
type PackageNameParam = string

// RepoKindParam Repository kind name:
// * `helm` - Helm charts
// * `falco` - Falco rules
// * `opa` - OPA policies
// * `olm` - OLM operators
// * `tbaction` - Tinkerbell actions
// * `krew` - Krew kubectl plugins
// * `helm-plugin` - Helm plugins
// * `tekton` - Tekton tasks
// * `keda-scaler` - KEDA scalers
// * `coredns` - Core DNS plugins
// * `keptn` - Keptn integrations
// * `tekton-pipeline` - Tekton pipelines
// * `container` - Container images
// * `kubewarden` - Kubewarden policies
// * `gatekeeper` - Gatekeeper policies
// * `kyverno` - Kyverno policies
// * `knative-client-plugin` - Knative client plugins
// * `backstage` - Backstage plugins
// * `argo-template` - Argo templates
// * `kubearmor` - KubeArmor policies
type RepoKindParam = RepositoryKindParam

// RepoNameParam defines model for RepoNameParam.
type RepoNameParam = string

// RepoNameQueryParam defines model for RepoNameQueryParam.
type RepoNameQueryParam = string

// RepositoriesListParam defines model for RepositoriesListParam.
type RepositoriesListParam = []string

// RepositoryKindsListParam defines model for RepositoryKindsListParam.
type RepositoryKindsListParam = []RepositoryKind

// ResourceKindNameParam Resource kind name:
//   - `repositoryName` - Repository name
//   - `repositoryURL` - Repository URL
//   - `organizationName` - Organization name
//   - `userAlias` - User alias
type ResourceKindNameParam = ResourceKindName

// SortParam defines model for SortParam.
type SortParam string

// TSQueryWebParam defines model for TSQueryWebParam.
type TSQueryWebParam = string

// UrlQueryParam defines model for UrlQueryParam.
type UrlQueryParam = string

// UserAliasParam defines model for UserAliasParam.
type UserAliasParam = string

// UsersListParam defines model for UsersListParam.
type UsersListParam = []string

// VerifiedPublisherParam defines model for VerifiedPublisherParam.
type VerifiedPublisherParam = bool

// VersionParam defines model for VersionParam.
type VersionParam = string

// WebhookIDParam defines model for WebhookIDParam.
type WebhookIDParam = openapi_types.UUID

// BadRequest defines model for BadRequest.
type BadRequest = Error

// Forbidden defines model for Forbidden.
type Forbidden = Error

// InternalServerError defines model for InternalServerError.
type InternalServerError = Error

// NotFoundResponse defines model for NotFoundResponse.
type NotFoundResponse = Error

// UnauthorizedError defines model for UnauthorizedError.
type UnauthorizedError = Error

// OptOutBody defines model for OptOutBody.
type OptOutBody struct {
	// EventKind Event kind:
	//   * `0` - New package release
	//   * `1` - Security alerts
	//   * `2` - Repository tracking errors
	//   * `4` - Repository scanning errors
	EventKind    EventKindId        `json:"event_kind"`
	RepositoryId openapi_types.UUID `json:"repository_id"`
}

// RepositoryBody defines model for RepositoryBody.
type RepositoryBody struct {
	DisplayName *string `json:"display_name,omitempty"`

	// Kind Repository kind:
	//   * `0` - Helm charts
	//   * `1` - Falco rules
	//   * `2` - OPA policies
	//   * `3` - OLM operators
	//   * `4` - Tinkerbell actions
	//   * `5` - Krew kubectl plugins
	//   * `6` - Helm plugins
	//   * `7` - Tekton tasks
	//   * `8` - KEDA scalers
	//   * `9` - Core DNS plugins
	//   * `10` - Keptn integrations
	//   * `11` - Tekton pipelines
	//   * `12` - Container images
	//   * `13` - Kubewarden policies
	//   * `14` - Gatekeeper policies
	//   * `15` - Kyverno policies
	//   * `16` - Knative client plugins
	//   * `17` - Backstage plugins
	//   * `18` - Argo templates
	//   * `19` - KubeArmor templates
	Kind *RepositoryKind `json:"kind,omitempty"`
	Name *string         `json:"name,omitempty"`
	Url  *string         `json:"url,omitempty"`
}

// SubscriptionBody defines model for SubscriptionBody.
type SubscriptionBody struct {
	// EventKind Event kind:
	//   * `0` - New package release
	//   * `1` - Security alerts
	//   * `2` - Repository tracking errors
	//   * `4` - Repository scanning errors
	EventKind EventKindId        `json:"event_kind"`
	PackageId openapi_types.UUID `json:"package_id"`
}

// WebhookBody defines model for WebhookBody.
type WebhookBody = WebhookSummaryWithPackages

// CheckAvailabilityParams defines parameters for CheckAvailability.
type CheckAvailabilityParams struct {
	// V Value to check
	V string `form:"v" json:"v"`
}

// GetUserOrganizationsParams defines parameters for GetUserOrganizations.
type GetUserOrganizationsParams struct {
	// Offset The number of items to skip before starting to collect the result set
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number of items to return
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`
}

// SearchPackagesParams defines parameters for SearchPackages.
type SearchPackagesParams struct {
	// Offset The number of items to skip before starting to collect the result set
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number of items to return
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Facets Whether we should get facets or not
	Facets FacetsParam `form:"facets" json:"facets"`

	// TsQueryWeb Text search query (websearch format)
	TsQueryWeb *TSQueryWebParam `form:"ts_query_web,omitempty" json:"ts_query_web,omitempty"`

	// Kind Repository kind:
	//   * `0` - Helm charts
	//   * `1` - Falco rules
	//   * `2` - OPA policies
	//   * `3` - OLM operators
	//   * `4` - Tinkerbell actions
	//   * `5` - Krew kubectl plugins
	//   * `6` - Helm plugins
	//   * `7` - Tekton tasks
	//   * `8` - KEDA scalers
	//   * `9` - Core DNS plugins
	//   * `10` - Keptn integrations
	//   * `11` - Tekton pipelines
	//   * `12` - Container images
	//   * `13` - Kubewarden policies
	//   * `14` - Gatekeeper policies
	//   * `15` - Kyverno policies
	//   * `16` - Knative client plugins
	//   * `17` - Backstage plugins
	//   * `18` - Argo templates
	//   * `19` - KubeArmor templates
	Kind *RepositoryKindsListParam `form:"kind,omitempty" json:"kind,omitempty"`

	// Category Package category:
	//   * `1` - AI / Machine learning
	//   * `2` - Database
	//   * `3` - Integration and delivery
	//   * `4` - Monitoring and logging
	//   * `5` - Networking
	//   * `6` - Security
	//   * `7` - Storage
	//   * `8` - Streaming and messaging
	Category *PackageCategoryListParam `form:"category,omitempty" json:"category,omitempty"`

	// User List of aliases
	User *UsersListParam `form:"user,omitempty" json:"user,omitempty"`

	// Org List of organization names
	Org *OrgsListParam `form:"org,omitempty" json:"org,omitempty"`

	// Repo List of repository names
	Repo *RepositoriesListParam `form:"repo,omitempty" json:"repo,omitempty"`

	// License List of SPDX identifiers
	License *LicensesListParam `form:"license,omitempty" json:"license,omitempty"`

	// Capabilities List of operator capability levels
	Capabilities *CapabilitiesListParam `form:"capabilities,omitempty" json:"capabilities,omitempty"`

	// Deprecated Whether to include deprecated packages or not
	Deprecated *DeprecatedParam `form:"deprecated,omitempty" json:"deprecated,omitempty"`

	// Operators Whether to get only operators
	Operators *OperatorsParam `form:"operators,omitempty" json:"operators,omitempty"`

	// VerifiedPublisher Whether to get only verified publisher
	VerifiedPublisher *VerifiedPublisherParam `form:"verified_publisher,omitempty" json:"verified_publisher,omitempty"`

	// Official Whether to get only official repositories
	Official *OfficialParam `form:"official,omitempty" json:"official,omitempty"`

	// Cncf Whether to get only pacakges published by CNCF projects
	Cncf *CNCFParam `form:"cncf,omitempty" json:"cncf,omitempty"`

	// Sort Sort criteria
	Sort *SearchPackagesParamsSort `form:"sort,omitempty" json:"sort,omitempty"`
}

// SearchPackagesParamsCategory defines parameters for SearchPackages.
type SearchPackagesParamsCategory int

// SearchPackagesParamsSort defines parameters for SearchPackages.
type SearchPackagesParamsSort string

// GetStarredPackagesByUserParams defines parameters for GetStarredPackagesByUser.
type GetStarredPackagesByUserParams struct {
	// Offset The number of items to skip before starting to collect the result set
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number of items to return
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`
}

// AddOrganizationRepositoryJSONBody defines parameters for AddOrganizationRepository.
type AddOrganizationRepositoryJSONBody struct {
	DisplayName *string `json:"display_name,omitempty"`

	// Kind Repository kind:
	//   * `0` - Helm charts
	//   * `1` - Falco rules
	//   * `2` - OPA policies
	//   * `3` - OLM operators
	//   * `4` - Tinkerbell actions
	//   * `5` - Krew kubectl plugins
	//   * `6` - Helm plugins
	//   * `7` - Tekton tasks
	//   * `8` - KEDA scalers
	//   * `9` - Core DNS plugins
	//   * `10` - Keptn integrations
	//   * `11` - Tekton pipelines
	//   * `12` - Container images
	//   * `13` - Kubewarden policies
	//   * `14` - Gatekeeper policies
	//   * `15` - Kyverno policies
	//   * `16` - Knative client plugins
	//   * `17` - Backstage plugins
	//   * `18` - Argo templates
	//   * `19` - KubeArmor templates
	Kind *RepositoryKind `json:"kind,omitempty"`
	Name *string         `json:"name,omitempty"`
	Url  *string         `json:"url,omitempty"`
}

// UpdateOrganizationRepositoryJSONBody defines parameters for UpdateOrganizationRepository.
type UpdateOrganizationRepositoryJSONBody struct {
	DisplayName *string `json:"display_name,omitempty"`

	// Kind Repository kind:
	//   * `0` - Helm charts
	//   * `1` - Falco rules
	//   * `2` - OPA policies
	//   * `3` - OLM operators
	//   * `4` - Tinkerbell actions
	//   * `5` - Krew kubectl plugins
	//   * `6` - Helm plugins
	//   * `7` - Tekton tasks
	//   * `8` - KEDA scalers
	//   * `9` - Core DNS plugins
	//   * `10` - Keptn integrations
	//   * `11` - Tekton pipelines
	//   * `12` - Container images
	//   * `13` - Kubewarden policies
	//   * `14` - Gatekeeper policies
	//   * `15` - Kyverno policies
	//   * `16` - Knative client plugins
	//   * `17` - Backstage plugins
	//   * `18` - Argo templates
	//   * `19` - KubeArmor templates
	Kind *RepositoryKind `json:"kind,omitempty"`
	Name *string         `json:"name,omitempty"`
	Url  *string         `json:"url,omitempty"`
}

// ClaimRepositoryOwnershipFromOrganizationParams defines parameters for ClaimRepositoryOwnershipFromOrganization.
type ClaimRepositoryOwnershipFromOrganizationParams struct {
	// Org The org to transfer or from claiming the repository
	Org *OrgNameToParam `form:"org,omitempty" json:"org,omitempty"`
}

// TransferRepositoryOwnershipParams defines parameters for TransferRepositoryOwnership.
type TransferRepositoryOwnershipParams struct {
	// Org The org to transfer or from claiming the repository
	Org *OrgNameToParam `form:"org,omitempty" json:"org,omitempty"`
}

// SearchRepositoriesParams defines parameters for SearchRepositories.
type SearchRepositoriesParams struct {
	// Offset The number of items to skip before starting to collect the result set
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number of items to return
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`

	// Kind Repository kind:
	//   * `0` - Helm charts
	//   * `1` - Falco rules
	//   * `2` - OPA policies
	//   * `3` - OLM operators
	//   * `4` - Tinkerbell actions
	//   * `5` - Krew kubectl plugins
	//   * `6` - Helm plugins
	//   * `7` - Tekton tasks
	//   * `8` - KEDA scalers
	//   * `9` - Core DNS plugins
	//   * `10` - Keptn integrations
	//   * `11` - Tekton pipelines
	//   * `12` - Container images
	//   * `13` - Kubewarden policies
	//   * `14` - Gatekeeper policies
	//   * `15` - Kyverno policies
	//   * `16` - Knative client plugins
	//   * `17` - Backstage plugins
	//   * `18` - Argo templates
	//   * `19` - KubeArmor templates
	Kind *RepositoryKindsListParam `form:"kind,omitempty" json:"kind,omitempty"`

	// User List of aliases
	User *UsersListParam `form:"user,omitempty" json:"user,omitempty"`

	// Org List of organization names
	Org *OrgsListParam `form:"org,omitempty" json:"org,omitempty"`

	// Name Repository name
	Name *RepoNameQueryParam `form:"name,omitempty" json:"name,omitempty"`

	// Url Repository url
	Url *UrlQueryParam `form:"url,omitempty" json:"url,omitempty"`
}

// AddUserRepositoryJSONBody defines parameters for AddUserRepository.
type AddUserRepositoryJSONBody struct {
	DisplayName *string `json:"display_name,omitempty"`

	// Kind Repository kind:
	//   * `0` - Helm charts
	//   * `1` - Falco rules
	//   * `2` - OPA policies
	//   * `3` - OLM operators
	//   * `4` - Tinkerbell actions
	//   * `5` - Krew kubectl plugins
	//   * `6` - Helm plugins
	//   * `7` - Tekton tasks
	//   * `8` - KEDA scalers
	//   * `9` - Core DNS plugins
	//   * `10` - Keptn integrations
	//   * `11` - Tekton pipelines
	//   * `12` - Container images
	//   * `13` - Kubewarden policies
	//   * `14` - Gatekeeper policies
	//   * `15` - Kyverno policies
	//   * `16` - Knative client plugins
	//   * `17` - Backstage plugins
	//   * `18` - Argo templates
	//   * `19` - KubeArmor templates
	Kind *RepositoryKind `json:"kind,omitempty"`
	Name *string         `json:"name,omitempty"`
	Url  *string         `json:"url,omitempty"`
}

// UpdateUserRepositoryJSONBody defines parameters for UpdateUserRepository.
type UpdateUserRepositoryJSONBody struct {
	DisplayName *string `json:"display_name,omitempty"`

	// Kind Repository kind:
	//   * `0` - Helm charts
	//   * `1` - Falco rules
	//   * `2` - OPA policies
	//   * `3` - OLM operators
	//   * `4` - Tinkerbell actions
	//   * `5` - Krew kubectl plugins
	//   * `6` - Helm plugins
	//   * `7` - Tekton tasks
	//   * `8` - KEDA scalers
	//   * `9` - Core DNS plugins
	//   * `10` - Keptn integrations
	//   * `11` - Tekton pipelines
	//   * `12` - Container images
	//   * `13` - Kubewarden policies
	//   * `14` - Gatekeeper policies
	//   * `15` - Kyverno policies
	//   * `16` - Knative client plugins
	//   * `17` - Backstage plugins
	//   * `18` - Argo templates
	//   * `19` - KubeArmor templates
	Kind *RepositoryKind `json:"kind,omitempty"`
	Name *string         `json:"name,omitempty"`
	Url  *string         `json:"url,omitempty"`
}

// ClaimRepositoryOwnershipParams defines parameters for ClaimRepositoryOwnership.
type ClaimRepositoryOwnershipParams struct {
	// Org The org to transfer or from claiming the repository
	Org *OrgNameToParam `form:"org,omitempty" json:"org,omitempty"`
}

// TransferRepositoryOwnershipToOrganizationParams defines parameters for TransferRepositoryOwnershipToOrganization.
type TransferRepositoryOwnershipToOrganizationParams struct {
	// Org The org to transfer or from claiming the repository
	Org *OrgNameToParam `form:"org,omitempty" json:"org,omitempty"`
}

// DeletePackageSubscriptionParams defines parameters for DeletePackageSubscription.
type DeletePackageSubscriptionParams struct {
	// PackageID Package ID
	PackageID PackageIDQueryParam `form:"packageID" json:"packageID"`

	// EventKind Event kind
	EventKind EventKindParam `form:"event_kind" json:"event_kind"`
}

// GetUserSubscriptionsParams defines parameters for GetUserSubscriptions.
type GetUserSubscriptionsParams struct {
	// Offset The number of items to skip before starting to collect the result set
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number of items to return
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`
}

// AddPackageSubscriptionJSONBody defines parameters for AddPackageSubscription.
type AddPackageSubscriptionJSONBody struct {
	// EventKind Event kind:
	//   * `0` - New package release
	//   * `1` - Security alerts
	//   * `2` - Repository tracking errors
	//   * `4` - Repository scanning errors
	EventKind EventKindId        `json:"event_kind"`
	PackageId openapi_types.UUID `json:"package_id"`
}

// GetUserOptOutEntriesParams defines parameters for GetUserOptOutEntries.
type GetUserOptOutEntriesParams struct {
	// Offset The number of items to skip before starting to collect the result set
	Offset *OffsetParam `form:"offset,omitempty" json:"offset,omitempty"`

	// Limit The number of items to return
	Limit *LimitParam `form:"limit,omitempty" json:"limit,omitempty"`
}

// AddOptOutEntryJSONBody defines parameters for AddOptOutEntry.
type AddOptOutEntryJSONBody struct {
	// EventKind Event kind:
	//   * `0` - New package release
	//   * `1` - Security alerts
	//   * `2` - Repository tracking errors
	//   * `4` - Repository scanning errors
	EventKind    EventKindId        `json:"event_kind"`
	RepositoryId openapi_types.UUID `json:"repository_id"`
}

// RegisterUserJSONBody defines parameters for RegisterUser.
type RegisterUserJSONBody struct {
	Alias     string              `json:"alias"`
	Email     openapi_types.Email `json:"email"`
	FirstName *string             `json:"first_name,omitempty"`
	LastName  *string             `json:"last_name,omitempty"`
	Password  string              `json:"password"`
}

// UpdateUserPasswordJSONBody defines parameters for UpdateUserPassword.
type UpdateUserPasswordJSONBody struct {
	New string `json:"new"`
	Old string `json:"old"`
}

// ResetPasswordCodeJSONBody defines parameters for ResetPasswordCode.
type ResetPasswordCodeJSONBody struct {
	Email string `json:"email"`
}

// ResetPasswordJSONBody defines parameters for ResetPassword.
type ResetPasswordJSONBody struct {
	Code     openapi_types.UUID `json:"code"`
	Password string             `json:"password"`
}

// VerifyEmailJSONBody defines parameters for VerifyEmail.
type VerifyEmailJSONBody struct {
	Code openapi_types.UUID `json:"code"`
}

// VerifyPasswordCodeJSONBody defines parameters for VerifyPasswordCode.
type VerifyPasswordCodeJSONBody struct {
	Code openapi_types.UUID `json:"code"`
}

// AddOrganizationJSONRequestBody defines body for AddOrganization for application/json ContentType.
type AddOrganizationJSONRequestBody = OrganizationSummary

// UpdateOrganizationProfileJSONRequestBody defines body for UpdateOrganizationProfile for application/json ContentType.
type UpdateOrganizationProfileJSONRequestBody = OrganizationSummary

// UpdateOrganizationAuthPolicyJSONRequestBody defines body for UpdateOrganizationAuthPolicy for application/json ContentType.
type UpdateOrganizationAuthPolicyJSONRequestBody = AuthorizationPolicy

// AddOrganizationRepositoryJSONRequestBody defines body for AddOrganizationRepository for application/json ContentType.
type AddOrganizationRepositoryJSONRequestBody AddOrganizationRepositoryJSONBody

// UpdateOrganizationRepositoryJSONRequestBody defines body for UpdateOrganizationRepository for application/json ContentType.
type UpdateOrganizationRepositoryJSONRequestBody UpdateOrganizationRepositoryJSONBody

// AddUserRepositoryJSONRequestBody defines body for AddUserRepository for application/json ContentType.
type AddUserRepositoryJSONRequestBody AddUserRepositoryJSONBody

// UpdateUserRepositoryJSONRequestBody defines body for UpdateUserRepository for application/json ContentType.
type UpdateUserRepositoryJSONRequestBody UpdateUserRepositoryJSONBody

// AddPackageSubscriptionJSONRequestBody defines body for AddPackageSubscription for application/json ContentType.
type AddPackageSubscriptionJSONRequestBody AddPackageSubscriptionJSONBody

// AddOptOutEntryJSONRequestBody defines body for AddOptOutEntry for application/json ContentType.
type AddOptOutEntryJSONRequestBody AddOptOutEntryJSONBody

// RegisterUserJSONRequestBody defines body for RegisterUser for application/json ContentType.
type RegisterUserJSONRequestBody RegisterUserJSONBody

// UpdateUserPasswordJSONRequestBody defines body for UpdateUserPassword for application/json ContentType.
type UpdateUserPasswordJSONRequestBody UpdateUserPasswordJSONBody

// ResetPasswordCodeJSONRequestBody defines body for ResetPasswordCode for application/json ContentType.
type ResetPasswordCodeJSONRequestBody ResetPasswordCodeJSONBody

// UpdateUserProfileJSONRequestBody defines body for UpdateUserProfile for application/json ContentType.
type UpdateUserProfileJSONRequestBody = User

// ResetPasswordJSONRequestBody defines body for ResetPassword for application/json ContentType.
type ResetPasswordJSONRequestBody ResetPasswordJSONBody

// VerifyEmailJSONRequestBody defines body for VerifyEmail for application/json ContentType.
type VerifyEmailJSONRequestBody VerifyEmailJSONBody

// VerifyPasswordCodeJSONRequestBody defines body for VerifyPasswordCode for application/json ContentType.
type VerifyPasswordCodeJSONRequestBody VerifyPasswordCodeJSONBody

// AddOrganizationWebhookJSONRequestBody defines body for AddOrganizationWebhook for application/json ContentType.
type AddOrganizationWebhookJSONRequestBody = WebhookSummaryWithPackages

// UpdateOrganizationWebhookJSONRequestBody defines body for UpdateOrganizationWebhook for application/json ContentType.
type UpdateOrganizationWebhookJSONRequestBody = WebhookSummaryWithPackages

// TriggerWebhookTestJSONRequestBody defines body for TriggerWebhookTest for application/json ContentType.
type TriggerWebhookTestJSONRequestBody = WebhookTest

// AddUserWebhookJSONRequestBody defines body for AddUserWebhook for application/json ContentType.
type AddUserWebhookJSONRequestBody = WebhookSummaryWithPackages

// UpdateUserWebhookJSONRequestBody defines body for UpdateUserWebhook for application/json ContentType.
type UpdateUserWebhookJSONRequestBody = WebhookSummaryWithPackages

// AsFalcoPackageDataRules0 returns the union data inside the FalcoPackage_Data_Rules as a FalcoPackageDataRules0
func (t FalcoPackage_Data_Rules) AsFalcoPackageDataRules0() (FalcoPackageDataRules0, error) {
	var body FalcoPackageDataRules0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFalcoPackageDataRules0 overwrites any union data inside the FalcoPackage_Data_Rules as the provided FalcoPackageDataRules0
func (t *FalcoPackage_Data_Rules) FromFalcoPackageDataRules0(v FalcoPackageDataRules0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFalcoPackageDataRules0 performs a merge with any union data inside the FalcoPackage_Data_Rules, using the provided FalcoPackageDataRules0
func (t *FalcoPackage_Data_Rules) MergeFalcoPackageDataRules0(v FalcoPackageDataRules0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

// AsFalcoPackageDataRules1 returns the union data inside the FalcoPackage_Data_Rules as a FalcoPackageDataRules1
func (t FalcoPackage_Data_Rules) AsFalcoPackageDataRules1() (FalcoPackageDataRules1, error) {
	var body FalcoPackageDataRules1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromFalcoPackageDataRules1 overwrites any union data inside the FalcoPackage_Data_Rules as the provided FalcoPackageDataRules1
func (t *FalcoPackage_Data_Rules) FromFalcoPackageDataRules1(v FalcoPackageDataRules1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeFalcoPackageDataRules1 performs a merge with any union data inside the FalcoPackage_Data_Rules, using the provided FalcoPackageDataRules1
func (t *FalcoPackage_Data_Rules) MergeFalcoPackageDataRules1(v FalcoPackageDataRules1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JsonMerge(t.union, b)
	t.union = merged
	return err
}

func (t FalcoPackage_Data_Rules) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FalcoPackage_Data_Rules) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// CheckAvailability request
	CheckAvailability(ctx context.Context, resourceKind ResourceKindNameParam, params *CheckAvailabilityParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHarborReplicationDump request
	GetHarborReplicationDump(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHelmExporterDump request
	GetHelmExporterDump(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNovaDump request
	GetNovaDump(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOrganizationWithBody request with any body
	AddOrganizationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOrganization(ctx context.Context, body AddOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserOrganizations request
	GetUserOrganizations(ctx context.Context, params *GetUserOrganizationsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrganization request
	DeleteOrganization(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationProfile request
	GetOrganizationProfile(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOrganizationProfileWithBody request with any body
	UpdateOrganizationProfileWithBody(ctx context.Context, orgName OrgNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOrganizationProfile(ctx context.Context, orgName OrgNameParam, body UpdateOrganizationProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AcceptOrganizationInvitation request
	AcceptOrganizationInvitation(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationAuthPolicy request
	GetOrganizationAuthPolicy(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOrganizationAuthPolicyWithBody request with any body
	UpdateOrganizationAuthPolicyWithBody(ctx context.Context, orgName OrgNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOrganizationAuthPolicy(ctx context.Context, orgName OrgNameParam, body UpdateOrganizationAuthPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrganizationMember request
	DeleteOrganizationMember(ctx context.Context, orgName OrgNameParam, userAlias UserAliasParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOrganizationMember request
	AddOrganizationMember(ctx context.Context, orgName OrgNameParam, userAlias UserAliasParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationMembers request
	GetOrganizationMembers(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAllowedActions request
	GetAllowedActions(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArgoTemplatesDetails request
	GetArgoTemplatesDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArgoTemplatesVersionDetails request
	GetArgoTemplatesVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackstagePluginsDetails request
	GetBackstagePluginsDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackstagePluginsVersionDetails request
	GetBackstagePluginsVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContainerImageDetails request
	GetContainerImageDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetContainerImageVersionDetails request
	GetContainerImageVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCoreDNSPluginDetails request
	GetCoreDNSPluginDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCoreDNSPluginVersionDetails request
	GetCoreDNSPluginVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFalcoRulesDetails request
	GetFalcoRulesDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFalcoRulesVersionDetails request
	GetFalcoRulesVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGatekeeperPoliciesDetails request
	GetGatekeeperPoliciesDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGatekeeperPoliciesVersionDetails request
	GetGatekeeperPoliciesVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHelmPluginDetails request
	GetHelmPluginDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHelmPluginVersionDetails request
	GetHelmPluginVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHelmPackageDetails request
	GetHelmPackageDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHelmPackageVersionDetails request
	GetHelmPackageVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKedaScalerDetails request
	GetKedaScalerDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKedaScalerVersionDetails request
	GetKedaScalerVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeptnIntegrationsDetails request
	GetKeptnIntegrationsDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKeptnIntegrationsVersionDetails request
	GetKeptnIntegrationsVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKnativeClientPluginIntegrationsDetails request
	GetKnativeClientPluginIntegrationsDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKnativeClientPluginsVersionDetails request
	GetKnativeClientPluginsVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKubectlPluginDetails request
	GetKubectlPluginDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKubectlPluginVersionDetails request
	GetKubectlPluginVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKubeArmorPoliciesDetails request
	GetKubeArmorPoliciesDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKubeArmorPoliciesVersionDetails request
	GetKubeArmorPoliciesVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKubewardenPoliciesDetails request
	GetKubewardenPoliciesDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKubewardenPoliciesVersionDetails request
	GetKubewardenPoliciesVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKyvernoPoliciesDetails request
	GetKyvernoPoliciesDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetKyvernoPoliciesVersionDetails request
	GetKyvernoPoliciesVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOLMOperatorDetails request
	GetOLMOperatorDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOLMOperatorVersionDetails request
	GetOLMOperatorVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOPAPoliciesDetails request
	GetOPAPoliciesDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOPAPoliciesVersionDetails request
	GetOPAPoliciesVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRandomPackages request
	GetRandomPackages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchPackages request
	SearchPackages(ctx context.Context, params *SearchPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStarredPackagesByUser request
	GetStarredPackagesByUser(ctx context.Context, params *GetStarredPackagesByUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPackageStats request
	GetPackageStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTinkerbellActionsDetails request
	GetTinkerbellActionsDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTinkerbellActionsVersionDetails request
	GetTinkerbellActionsVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTektonPipelineDetails request
	GetTektonPipelineDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTektonPipelineVersionDetails request
	GetTektonPipelineVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTektonTaskDetails request
	GetTektonTaskDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTektonTaskVersionDetails request
	GetTektonTaskVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPackageChangelog request
	GetPackageChangelog(ctx context.Context, packageID PackageIDParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPackageStars request
	GetPackageStars(ctx context.Context, packageID PackageIDParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TogglePackageStar request
	TogglePackageStar(ctx context.Context, packageID PackageIDParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPackageViews request
	GetPackageViews(ctx context.Context, packageID PackageIDParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPackageSecurityReport request
	GetPackageSecurityReport(ctx context.Context, packageID PackageIDParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetHelmChartTemplates request
	GetHelmChartTemplates(ctx context.Context, packageID PackageIDParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChartValues request
	GetChartValues(ctx context.Context, packageID PackageIDParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPackageValuesSchema request
	GetPackageValuesSchema(ctx context.Context, packageID PackageIDParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GenerateChangelogMD request
	GenerateChangelogMD(ctx context.Context, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetProductionUsage request
	GetProductionUsage(ctx context.Context, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteProductionUsage request
	DeleteProductionUsage(ctx context.Context, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddProductionUsage request
	AddProductionUsage(ctx context.Context, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPackageSummary request
	GetPackageSummary(ctx context.Context, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOrganizationRepositoryWithBody request with any body
	AddOrganizationRepositoryWithBody(ctx context.Context, orgName OrgNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOrganizationRepository(ctx context.Context, orgName OrgNameParam, body AddOrganizationRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrganizationRepository request
	DeleteOrganizationRepository(ctx context.Context, orgName OrgNameParam, repoName RepoNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOrganizationRepositoryWithBody request with any body
	UpdateOrganizationRepositoryWithBody(ctx context.Context, orgName OrgNameParam, repoName RepoNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOrganizationRepository(ctx context.Context, orgName OrgNameParam, repoName RepoNameParam, body UpdateOrganizationRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClaimRepositoryOwnershipFromOrganization request
	ClaimRepositoryOwnershipFromOrganization(ctx context.Context, orgName OrgNameParam, repoName RepoNameParam, params *ClaimRepositoryOwnershipFromOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferRepositoryOwnership request
	TransferRepositoryOwnership(ctx context.Context, orgName OrgNameParam, repoName RepoNameParam, params *TransferRepositoryOwnershipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchRepositories request
	SearchRepositories(ctx context.Context, params *SearchRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUserRepositoryWithBody request with any body
	AddUserRepositoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUserRepository(ctx context.Context, body AddUserRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserRepository request
	DeleteUserRepository(ctx context.Context, repoName RepoNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserRepositoryWithBody request with any body
	UpdateUserRepositoryWithBody(ctx context.Context, repoName RepoNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserRepository(ctx context.Context, repoName RepoNameParam, body UpdateUserRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ClaimRepositoryOwnership request
	ClaimRepositoryOwnership(ctx context.Context, repoName RepoNameParam, params *ClaimRepositoryOwnershipParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TransferRepositoryOwnershipToOrganization request
	TransferRepositoryOwnershipToOrganization(ctx context.Context, repoName RepoNameParam, params *TransferRepositoryOwnershipToOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetArtifactHubStats request
	GetArtifactHubStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePackageSubscription request
	DeletePackageSubscription(ctx context.Context, params *DeletePackageSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserSubscriptions request
	GetUserSubscriptions(ctx context.Context, params *GetUserSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddPackageSubscriptionWithBody request with any body
	AddPackageSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddPackageSubscription(ctx context.Context, body AddPackageSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserOptOutEntries request
	GetUserOptOutEntries(ctx context.Context, params *GetUserOptOutEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOptOutEntryWithBody request with any body
	AddOptOutEntryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOptOutEntry(ctx context.Context, body AddOptOutEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOptOutEntry request
	DeleteOptOutEntry(ctx context.Context, optOutID OptOutIDParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPackageUserSubscriptions request
	GetPackageUserSubscriptions(ctx context.Context, packageID PackageIDParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RegisterUserWithBody request with any body
	RegisterUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RegisterUser(ctx context.Context, body RegisterUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserPasswordWithBody request with any body
	UpdateUserPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserPassword(ctx context.Context, body UpdateUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetPasswordCodeWithBody request with any body
	ResetPasswordCodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetPasswordCode(ctx context.Context, body ResetPasswordCodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserProfile request
	GetUserProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserProfileWithBody request with any body
	UpdateUserProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserProfile(ctx context.Context, body UpdateUserProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResetPasswordWithBody request with any body
	ResetPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResetPassword(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VerifyEmailWithBody request with any body
	VerifyEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VerifyEmail(ctx context.Context, body VerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// VerifyPasswordCodeWithBody request with any body
	VerifyPasswordCodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	VerifyPasswordCode(ctx context.Context, body VerifyPasswordCodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationWebhooks request
	GetOrganizationWebhooks(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddOrganizationWebhookWithBody request with any body
	AddOrganizationWebhookWithBody(ctx context.Context, orgName OrgNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddOrganizationWebhook(ctx context.Context, orgName OrgNameParam, body AddOrganizationWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteOrganizationWebhook request
	DeleteOrganizationWebhook(ctx context.Context, orgName OrgNameParam, webhookID WebhookIDParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetOrganizationWebhookDetails request
	GetOrganizationWebhookDetails(ctx context.Context, orgName OrgNameParam, webhookID WebhookIDParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateOrganizationWebhookWithBody request with any body
	UpdateOrganizationWebhookWithBody(ctx context.Context, orgName OrgNameParam, webhookID WebhookIDParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateOrganizationWebhook(ctx context.Context, orgName OrgNameParam, webhookID WebhookIDParam, body UpdateOrganizationWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TriggerWebhookTestWithBody request with any body
	TriggerWebhookTestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TriggerWebhookTest(ctx context.Context, body TriggerWebhookTestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserWebhooks request
	GetUserWebhooks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddUserWebhookWithBody request with any body
	AddUserWebhookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddUserWebhook(ctx context.Context, body AddUserWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserWebhook request
	DeleteUserWebhook(ctx context.Context, webhookID WebhookIDParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserWebhookDetail request
	GetUserWebhookDetail(ctx context.Context, webhookID WebhookIDParam, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateUserWebhookWithBody request with any body
	UpdateUserWebhookWithBody(ctx context.Context, webhookID WebhookIDParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateUserWebhook(ctx context.Context, webhookID WebhookIDParam, body UpdateUserWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) CheckAvailability(ctx context.Context, resourceKind ResourceKindNameParam, params *CheckAvailabilityParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckAvailabilityRequest(c.Server, resourceKind, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHarborReplicationDump(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHarborReplicationDumpRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHelmExporterDump(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHelmExporterDumpRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNovaDump(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNovaDumpRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganization(ctx context.Context, body AddOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserOrganizations(ctx context.Context, params *GetUserOrganizationsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserOrganizationsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrganization(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrganizationRequest(c.Server, orgName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationProfile(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationProfileRequest(c.Server, orgName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrganizationProfileWithBody(ctx context.Context, orgName OrgNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrganizationProfileRequestWithBody(c.Server, orgName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrganizationProfile(ctx context.Context, orgName OrgNameParam, body UpdateOrganizationProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrganizationProfileRequest(c.Server, orgName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AcceptOrganizationInvitation(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAcceptOrganizationInvitationRequest(c.Server, orgName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationAuthPolicy(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationAuthPolicyRequest(c.Server, orgName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrganizationAuthPolicyWithBody(ctx context.Context, orgName OrgNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrganizationAuthPolicyRequestWithBody(c.Server, orgName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrganizationAuthPolicy(ctx context.Context, orgName OrgNameParam, body UpdateOrganizationAuthPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrganizationAuthPolicyRequest(c.Server, orgName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrganizationMember(ctx context.Context, orgName OrgNameParam, userAlias UserAliasParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrganizationMemberRequest(c.Server, orgName, userAlias)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationMember(ctx context.Context, orgName OrgNameParam, userAlias UserAliasParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationMemberRequest(c.Server, orgName, userAlias)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationMembers(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationMembersRequest(c.Server, orgName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAllowedActions(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAllowedActionsRequest(c.Server, orgName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArgoTemplatesDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArgoTemplatesDetailsRequest(c.Server, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArgoTemplatesVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArgoTemplatesVersionDetailsRequest(c.Server, repoName, packageName, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackstagePluginsDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackstagePluginsDetailsRequest(c.Server, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackstagePluginsVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackstagePluginsVersionDetailsRequest(c.Server, repoName, packageName, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContainerImageDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContainerImageDetailsRequest(c.Server, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetContainerImageVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetContainerImageVersionDetailsRequest(c.Server, repoName, packageName, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCoreDNSPluginDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCoreDNSPluginDetailsRequest(c.Server, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCoreDNSPluginVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCoreDNSPluginVersionDetailsRequest(c.Server, repoName, packageName, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFalcoRulesDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFalcoRulesDetailsRequest(c.Server, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFalcoRulesVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFalcoRulesVersionDetailsRequest(c.Server, repoName, packageName, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGatekeeperPoliciesDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGatekeeperPoliciesDetailsRequest(c.Server, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGatekeeperPoliciesVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGatekeeperPoliciesVersionDetailsRequest(c.Server, repoName, packageName, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHelmPluginDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHelmPluginDetailsRequest(c.Server, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHelmPluginVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHelmPluginVersionDetailsRequest(c.Server, repoName, packageName, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHelmPackageDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHelmPackageDetailsRequest(c.Server, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHelmPackageVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHelmPackageVersionDetailsRequest(c.Server, repoName, packageName, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKedaScalerDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKedaScalerDetailsRequest(c.Server, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKedaScalerVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKedaScalerVersionDetailsRequest(c.Server, repoName, packageName, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeptnIntegrationsDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeptnIntegrationsDetailsRequest(c.Server, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKeptnIntegrationsVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKeptnIntegrationsVersionDetailsRequest(c.Server, repoName, packageName, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKnativeClientPluginIntegrationsDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKnativeClientPluginIntegrationsDetailsRequest(c.Server, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKnativeClientPluginsVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKnativeClientPluginsVersionDetailsRequest(c.Server, repoName, packageName, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKubectlPluginDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKubectlPluginDetailsRequest(c.Server, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKubectlPluginVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKubectlPluginVersionDetailsRequest(c.Server, repoName, packageName, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKubeArmorPoliciesDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKubeArmorPoliciesDetailsRequest(c.Server, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKubeArmorPoliciesVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKubeArmorPoliciesVersionDetailsRequest(c.Server, repoName, packageName, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKubewardenPoliciesDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKubewardenPoliciesDetailsRequest(c.Server, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKubewardenPoliciesVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKubewardenPoliciesVersionDetailsRequest(c.Server, repoName, packageName, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKyvernoPoliciesDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKyvernoPoliciesDetailsRequest(c.Server, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetKyvernoPoliciesVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetKyvernoPoliciesVersionDetailsRequest(c.Server, repoName, packageName, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOLMOperatorDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOLMOperatorDetailsRequest(c.Server, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOLMOperatorVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOLMOperatorVersionDetailsRequest(c.Server, repoName, packageName, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOPAPoliciesDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOPAPoliciesDetailsRequest(c.Server, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOPAPoliciesVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOPAPoliciesVersionDetailsRequest(c.Server, repoName, packageName, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRandomPackages(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRandomPackagesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchPackages(ctx context.Context, params *SearchPackagesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchPackagesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStarredPackagesByUser(ctx context.Context, params *GetStarredPackagesByUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStarredPackagesByUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPackageStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPackageStatsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTinkerbellActionsDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTinkerbellActionsDetailsRequest(c.Server, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTinkerbellActionsVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTinkerbellActionsVersionDetailsRequest(c.Server, repoName, packageName, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTektonPipelineDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTektonPipelineDetailsRequest(c.Server, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTektonPipelineVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTektonPipelineVersionDetailsRequest(c.Server, repoName, packageName, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTektonTaskDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTektonTaskDetailsRequest(c.Server, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTektonTaskVersionDetails(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTektonTaskVersionDetailsRequest(c.Server, repoName, packageName, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPackageChangelog(ctx context.Context, packageID PackageIDParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPackageChangelogRequest(c.Server, packageID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPackageStars(ctx context.Context, packageID PackageIDParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPackageStarsRequest(c.Server, packageID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TogglePackageStar(ctx context.Context, packageID PackageIDParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTogglePackageStarRequest(c.Server, packageID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPackageViews(ctx context.Context, packageID PackageIDParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPackageViewsRequest(c.Server, packageID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPackageSecurityReport(ctx context.Context, packageID PackageIDParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPackageSecurityReportRequest(c.Server, packageID, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetHelmChartTemplates(ctx context.Context, packageID PackageIDParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetHelmChartTemplatesRequest(c.Server, packageID, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChartValues(ctx context.Context, packageID PackageIDParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChartValuesRequest(c.Server, packageID, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPackageValuesSchema(ctx context.Context, packageID PackageIDParam, version VersionParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPackageValuesSchemaRequest(c.Server, packageID, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GenerateChangelogMD(ctx context.Context, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGenerateChangelogMDRequest(c.Server, repoKindParam, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetProductionUsage(ctx context.Context, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetProductionUsageRequest(c.Server, repoKindParam, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteProductionUsage(ctx context.Context, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteProductionUsageRequest(c.Server, repoKindParam, repoName, packageName, orgName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddProductionUsage(ctx context.Context, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddProductionUsageRequest(c.Server, repoKindParam, repoName, packageName, orgName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPackageSummary(ctx context.Context, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPackageSummaryRequest(c.Server, repoKindParam, repoName, packageName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationRepositoryWithBody(ctx context.Context, orgName OrgNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationRepositoryRequestWithBody(c.Server, orgName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationRepository(ctx context.Context, orgName OrgNameParam, body AddOrganizationRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationRepositoryRequest(c.Server, orgName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrganizationRepository(ctx context.Context, orgName OrgNameParam, repoName RepoNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrganizationRepositoryRequest(c.Server, orgName, repoName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrganizationRepositoryWithBody(ctx context.Context, orgName OrgNameParam, repoName RepoNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrganizationRepositoryRequestWithBody(c.Server, orgName, repoName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrganizationRepository(ctx context.Context, orgName OrgNameParam, repoName RepoNameParam, body UpdateOrganizationRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrganizationRepositoryRequest(c.Server, orgName, repoName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClaimRepositoryOwnershipFromOrganization(ctx context.Context, orgName OrgNameParam, repoName RepoNameParam, params *ClaimRepositoryOwnershipFromOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClaimRepositoryOwnershipFromOrganizationRequest(c.Server, orgName, repoName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferRepositoryOwnership(ctx context.Context, orgName OrgNameParam, repoName RepoNameParam, params *TransferRepositoryOwnershipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferRepositoryOwnershipRequest(c.Server, orgName, repoName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchRepositories(ctx context.Context, params *SearchRepositoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRepositoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserRepositoryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserRepositoryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserRepository(ctx context.Context, body AddUserRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserRepositoryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserRepository(ctx context.Context, repoName RepoNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserRepositoryRequest(c.Server, repoName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserRepositoryWithBody(ctx context.Context, repoName RepoNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRepositoryRequestWithBody(c.Server, repoName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserRepository(ctx context.Context, repoName RepoNameParam, body UpdateUserRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserRepositoryRequest(c.Server, repoName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ClaimRepositoryOwnership(ctx context.Context, repoName RepoNameParam, params *ClaimRepositoryOwnershipParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewClaimRepositoryOwnershipRequest(c.Server, repoName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TransferRepositoryOwnershipToOrganization(ctx context.Context, repoName RepoNameParam, params *TransferRepositoryOwnershipToOrganizationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTransferRepositoryOwnershipToOrganizationRequest(c.Server, repoName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetArtifactHubStats(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetArtifactHubStatsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePackageSubscription(ctx context.Context, params *DeletePackageSubscriptionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePackageSubscriptionRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserSubscriptions(ctx context.Context, params *GetUserSubscriptionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserSubscriptionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPackageSubscriptionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPackageSubscriptionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddPackageSubscription(ctx context.Context, body AddPackageSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddPackageSubscriptionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserOptOutEntries(ctx context.Context, params *GetUserOptOutEntriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserOptOutEntriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOptOutEntryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOptOutEntryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOptOutEntry(ctx context.Context, body AddOptOutEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOptOutEntryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOptOutEntry(ctx context.Context, optOutID OptOutIDParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOptOutEntryRequest(c.Server, optOutID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPackageUserSubscriptions(ctx context.Context, packageID PackageIDParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPackageUserSubscriptionsRequest(c.Server, packageID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterUserWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterUserRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RegisterUser(ctx context.Context, body RegisterUserJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRegisterUserRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserPasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserPassword(ctx context.Context, body UpdateUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserPasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPasswordCodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordCodeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPasswordCode(ctx context.Context, body ResetPasswordCodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordCodeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserProfile(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserProfileRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserProfileWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserProfileRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserProfile(ctx context.Context, body UpdateUserProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserProfileRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPasswordWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResetPassword(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResetPasswordRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyEmailWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyEmailRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyEmail(ctx context.Context, body VerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyEmailRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyPasswordCodeWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyPasswordCodeRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) VerifyPasswordCode(ctx context.Context, body VerifyPasswordCodeJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewVerifyPasswordCodeRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationWebhooks(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationWebhooksRequest(c.Server, orgName)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationWebhookWithBody(ctx context.Context, orgName OrgNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationWebhookRequestWithBody(c.Server, orgName, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddOrganizationWebhook(ctx context.Context, orgName OrgNameParam, body AddOrganizationWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddOrganizationWebhookRequest(c.Server, orgName, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteOrganizationWebhook(ctx context.Context, orgName OrgNameParam, webhookID WebhookIDParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteOrganizationWebhookRequest(c.Server, orgName, webhookID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetOrganizationWebhookDetails(ctx context.Context, orgName OrgNameParam, webhookID WebhookIDParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetOrganizationWebhookDetailsRequest(c.Server, orgName, webhookID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrganizationWebhookWithBody(ctx context.Context, orgName OrgNameParam, webhookID WebhookIDParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrganizationWebhookRequestWithBody(c.Server, orgName, webhookID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateOrganizationWebhook(ctx context.Context, orgName OrgNameParam, webhookID WebhookIDParam, body UpdateOrganizationWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateOrganizationWebhookRequest(c.Server, orgName, webhookID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerWebhookTestWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerWebhookTestRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TriggerWebhookTest(ctx context.Context, body TriggerWebhookTestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTriggerWebhookTestRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserWebhooks(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserWebhooksRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserWebhookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserWebhookRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddUserWebhook(ctx context.Context, body AddUserWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddUserWebhookRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserWebhook(ctx context.Context, webhookID WebhookIDParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserWebhookRequest(c.Server, webhookID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserWebhookDetail(ctx context.Context, webhookID WebhookIDParam, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserWebhookDetailRequest(c.Server, webhookID)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWebhookWithBody(ctx context.Context, webhookID WebhookIDParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserWebhookRequestWithBody(c.Server, webhookID, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateUserWebhook(ctx context.Context, webhookID WebhookIDParam, body UpdateUserWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateUserWebhookRequest(c.Server, webhookID, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCheckAvailabilityRequest generates requests for CheckAvailability
func NewCheckAvailabilityRequest(server string, resourceKind ResourceKindNameParam, params *CheckAvailabilityParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "resourceKind", runtime.ParamLocationPath, resourceKind)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/check-availability/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "v", runtime.ParamLocationQuery, params.V); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHarborReplicationDumpRequest generates requests for GetHarborReplicationDump
func NewGetHarborReplicationDumpRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/harbor-replication")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHelmExporterDumpRequest generates requests for GetHelmExporterDump
func NewGetHelmExporterDumpRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/helm-exporter")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNovaDumpRequest generates requests for GetNovaDump
func NewGetNovaDumpRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nova")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddOrganizationRequest calls the generic AddOrganization builder with application/json body
func NewAddOrganizationRequest(server string, body AddOrganizationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOrganizationRequestWithBody(server, "application/json", bodyReader)
}

// NewAddOrganizationRequestWithBody generates requests for AddOrganization with any type of body
func NewAddOrganizationRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserOrganizationsRequest generates requests for GetUserOrganizations
func NewGetUserOrganizationsRequest(server string, params *GetUserOrganizationsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteOrganizationRequest generates requests for DeleteOrganization
func NewDeleteOrganizationRequest(server string, orgName OrgNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgName", runtime.ParamLocationPath, orgName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationProfileRequest generates requests for GetOrganizationProfile
func NewGetOrganizationProfileRequest(server string, orgName OrgNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgName", runtime.ParamLocationPath, orgName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOrganizationProfileRequest calls the generic UpdateOrganizationProfile builder with application/json body
func NewUpdateOrganizationProfileRequest(server string, orgName OrgNameParam, body UpdateOrganizationProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOrganizationProfileRequestWithBody(server, orgName, "application/json", bodyReader)
}

// NewUpdateOrganizationProfileRequestWithBody generates requests for UpdateOrganizationProfile with any type of body
func NewUpdateOrganizationProfileRequestWithBody(server string, orgName OrgNameParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgName", runtime.ParamLocationPath, orgName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAcceptOrganizationInvitationRequest generates requests for AcceptOrganizationInvitation
func NewAcceptOrganizationInvitationRequest(server string, orgName OrgNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgName", runtime.ParamLocationPath, orgName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/accept-invitation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationAuthPolicyRequest generates requests for GetOrganizationAuthPolicy
func NewGetOrganizationAuthPolicyRequest(server string, orgName OrgNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgName", runtime.ParamLocationPath, orgName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/authorization-policy", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOrganizationAuthPolicyRequest calls the generic UpdateOrganizationAuthPolicy builder with application/json body
func NewUpdateOrganizationAuthPolicyRequest(server string, orgName OrgNameParam, body UpdateOrganizationAuthPolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOrganizationAuthPolicyRequestWithBody(server, orgName, "application/json", bodyReader)
}

// NewUpdateOrganizationAuthPolicyRequestWithBody generates requests for UpdateOrganizationAuthPolicy with any type of body
func NewUpdateOrganizationAuthPolicyRequestWithBody(server string, orgName OrgNameParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgName", runtime.ParamLocationPath, orgName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/authorization-policy", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOrganizationMemberRequest generates requests for DeleteOrganizationMember
func NewDeleteOrganizationMemberRequest(server string, orgName OrgNameParam, userAlias UserAliasParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgName", runtime.ParamLocationPath, orgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userAlias", runtime.ParamLocationPath, userAlias)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/member/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddOrganizationMemberRequest generates requests for AddOrganizationMember
func NewAddOrganizationMemberRequest(server string, orgName OrgNameParam, userAlias UserAliasParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgName", runtime.ParamLocationPath, orgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "userAlias", runtime.ParamLocationPath, userAlias)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/member/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationMembersRequest generates requests for GetOrganizationMembers
func NewGetOrganizationMembersRequest(server string, orgName OrgNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgName", runtime.ParamLocationPath, orgName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/members", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAllowedActionsRequest generates requests for GetAllowedActions
func NewGetAllowedActionsRequest(server string, orgName OrgNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgName", runtime.ParamLocationPath, orgName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/orgs/%s/user-allowed-actions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArgoTemplatesDetailsRequest generates requests for GetArgoTemplatesDetails
func NewGetArgoTemplatesDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/argo-template/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArgoTemplatesVersionDetailsRequest generates requests for GetArgoTemplatesVersionDetails
func NewGetArgoTemplatesVersionDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/argo-template/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBackstagePluginsDetailsRequest generates requests for GetBackstagePluginsDetails
func NewGetBackstagePluginsDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/backstage/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBackstagePluginsVersionDetailsRequest generates requests for GetBackstagePluginsVersionDetails
func NewGetBackstagePluginsVersionDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/backstage/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContainerImageDetailsRequest generates requests for GetContainerImageDetails
func NewGetContainerImageDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/container/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetContainerImageVersionDetailsRequest generates requests for GetContainerImageVersionDetails
func NewGetContainerImageVersionDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/container/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCoreDNSPluginDetailsRequest generates requests for GetCoreDNSPluginDetails
func NewGetCoreDNSPluginDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/coredns/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCoreDNSPluginVersionDetailsRequest generates requests for GetCoreDNSPluginVersionDetails
func NewGetCoreDNSPluginVersionDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/coredns/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFalcoRulesDetailsRequest generates requests for GetFalcoRulesDetails
func NewGetFalcoRulesDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/falco/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFalcoRulesVersionDetailsRequest generates requests for GetFalcoRulesVersionDetails
func NewGetFalcoRulesVersionDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/falco/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGatekeeperPoliciesDetailsRequest generates requests for GetGatekeeperPoliciesDetails
func NewGetGatekeeperPoliciesDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/gatekeeper/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGatekeeperPoliciesVersionDetailsRequest generates requests for GetGatekeeperPoliciesVersionDetails
func NewGetGatekeeperPoliciesVersionDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/gatekeeper/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHelmPluginDetailsRequest generates requests for GetHelmPluginDetails
func NewGetHelmPluginDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/helm-plugin/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHelmPluginVersionDetailsRequest generates requests for GetHelmPluginVersionDetails
func NewGetHelmPluginVersionDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/helm-plugin/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHelmPackageDetailsRequest generates requests for GetHelmPackageDetails
func NewGetHelmPackageDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/helm/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHelmPackageVersionDetailsRequest generates requests for GetHelmPackageVersionDetails
func NewGetHelmPackageVersionDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/helm/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKedaScalerDetailsRequest generates requests for GetKedaScalerDetails
func NewGetKedaScalerDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/keda-scaler/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKedaScalerVersionDetailsRequest generates requests for GetKedaScalerVersionDetails
func NewGetKedaScalerVersionDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/keda-scaler/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeptnIntegrationsDetailsRequest generates requests for GetKeptnIntegrationsDetails
func NewGetKeptnIntegrationsDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/keptn/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKeptnIntegrationsVersionDetailsRequest generates requests for GetKeptnIntegrationsVersionDetails
func NewGetKeptnIntegrationsVersionDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/keptn/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKnativeClientPluginIntegrationsDetailsRequest generates requests for GetKnativeClientPluginIntegrationsDetails
func NewGetKnativeClientPluginIntegrationsDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/knative-client-plugin/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKnativeClientPluginsVersionDetailsRequest generates requests for GetKnativeClientPluginsVersionDetails
func NewGetKnativeClientPluginsVersionDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/knative-client-plugin/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKubectlPluginDetailsRequest generates requests for GetKubectlPluginDetails
func NewGetKubectlPluginDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/krew/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKubectlPluginVersionDetailsRequest generates requests for GetKubectlPluginVersionDetails
func NewGetKubectlPluginVersionDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/krew/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKubeArmorPoliciesDetailsRequest generates requests for GetKubeArmorPoliciesDetails
func NewGetKubeArmorPoliciesDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/kubearmor/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKubeArmorPoliciesVersionDetailsRequest generates requests for GetKubeArmorPoliciesVersionDetails
func NewGetKubeArmorPoliciesVersionDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/kubearmor/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKubewardenPoliciesDetailsRequest generates requests for GetKubewardenPoliciesDetails
func NewGetKubewardenPoliciesDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/kubewarden/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKubewardenPoliciesVersionDetailsRequest generates requests for GetKubewardenPoliciesVersionDetails
func NewGetKubewardenPoliciesVersionDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/kubewarden/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKyvernoPoliciesDetailsRequest generates requests for GetKyvernoPoliciesDetails
func NewGetKyvernoPoliciesDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/kyverno/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetKyvernoPoliciesVersionDetailsRequest generates requests for GetKyvernoPoliciesVersionDetails
func NewGetKyvernoPoliciesVersionDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/kyverno/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOLMOperatorDetailsRequest generates requests for GetOLMOperatorDetails
func NewGetOLMOperatorDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/olm/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOLMOperatorVersionDetailsRequest generates requests for GetOLMOperatorVersionDetails
func NewGetOLMOperatorVersionDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/olm/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOPAPoliciesDetailsRequest generates requests for GetOPAPoliciesDetails
func NewGetOPAPoliciesDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/opa/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOPAPoliciesVersionDetailsRequest generates requests for GetOPAPoliciesVersionDetails
func NewGetOPAPoliciesVersionDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/opa/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRandomPackagesRequest generates requests for GetRandomPackages
func NewGetRandomPackagesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/random")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchPackagesRequest generates requests for SearchPackages
func NewSearchPackagesRequest(server string, params *SearchPackagesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "facets", runtime.ParamLocationQuery, params.Facets); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.TsQueryWeb != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ts_query_web", runtime.ParamLocationQuery, *params.TsQueryWeb); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kind", runtime.ParamLocationQuery, *params.Kind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Category != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category", runtime.ParamLocationQuery, *params.Category); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Org != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Repo != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "repo", runtime.ParamLocationQuery, *params.Repo); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.License != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "license", runtime.ParamLocationQuery, *params.License); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Capabilities != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "capabilities", runtime.ParamLocationQuery, *params.Capabilities); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Deprecated != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "deprecated", runtime.ParamLocationQuery, *params.Deprecated); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Operators != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "operators", runtime.ParamLocationQuery, *params.Operators); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.VerifiedPublisher != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "verified_publisher", runtime.ParamLocationQuery, *params.VerifiedPublisher); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Official != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "official", runtime.ParamLocationQuery, *params.Official); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Cncf != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "cncf", runtime.ParamLocationQuery, *params.Cncf); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sort != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sort", runtime.ParamLocationQuery, *params.Sort); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStarredPackagesByUserRequest generates requests for GetStarredPackagesByUser
func NewGetStarredPackagesByUserRequest(server string, params *GetStarredPackagesByUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/starred")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPackageStatsRequest generates requests for GetPackageStats
func NewGetPackageStatsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTinkerbellActionsDetailsRequest generates requests for GetTinkerbellActionsDetails
func NewGetTinkerbellActionsDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/tbaction/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTinkerbellActionsVersionDetailsRequest generates requests for GetTinkerbellActionsVersionDetails
func NewGetTinkerbellActionsVersionDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/tbaction/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTektonPipelineDetailsRequest generates requests for GetTektonPipelineDetails
func NewGetTektonPipelineDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/tekton-pipeline/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTektonPipelineVersionDetailsRequest generates requests for GetTektonPipelineVersionDetails
func NewGetTektonPipelineVersionDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/tekton-pipeline/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTektonTaskDetailsRequest generates requests for GetTektonTaskDetails
func NewGetTektonTaskDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/tekton-task/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTektonTaskVersionDetailsRequest generates requests for GetTektonTaskVersionDetails
func NewGetTektonTaskVersionDetailsRequest(server string, repoName RepoNameParam, packageName PackageNameParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/tekton-task/%s/%s/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPackageChangelogRequest generates requests for GetPackageChangelog
func NewGetPackageChangelogRequest(server string, packageID PackageIDParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packageID", runtime.ParamLocationPath, packageID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/%s/changelog", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPackageStarsRequest generates requests for GetPackageStars
func NewGetPackageStarsRequest(server string, packageID PackageIDParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packageID", runtime.ParamLocationPath, packageID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/%s/stars", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTogglePackageStarRequest generates requests for TogglePackageStar
func NewTogglePackageStarRequest(server string, packageID PackageIDParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packageID", runtime.ParamLocationPath, packageID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/%s/stars", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPackageViewsRequest generates requests for GetPackageViews
func NewGetPackageViewsRequest(server string, packageID PackageIDParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packageID", runtime.ParamLocationPath, packageID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/%s/views", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPackageSecurityReportRequest generates requests for GetPackageSecurityReport
func NewGetPackageSecurityReportRequest(server string, packageID PackageIDParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packageID", runtime.ParamLocationPath, packageID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/%s/%s/security-report", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetHelmChartTemplatesRequest generates requests for GetHelmChartTemplates
func NewGetHelmChartTemplatesRequest(server string, packageID PackageIDParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packageID", runtime.ParamLocationPath, packageID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/%s/%s/templates", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChartValuesRequest generates requests for GetChartValues
func NewGetChartValuesRequest(server string, packageID PackageIDParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packageID", runtime.ParamLocationPath, packageID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/%s/%s/values", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPackageValuesSchemaRequest generates requests for GetPackageValuesSchema
func NewGetPackageValuesSchemaRequest(server string, packageID PackageIDParam, version VersionParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packageID", runtime.ParamLocationPath, packageID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/%s/%s/values-schema", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGenerateChangelogMDRequest generates requests for GenerateChangelogMD
func NewGenerateChangelogMDRequest(server string, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoKindParam", runtime.ParamLocationPath, repoKindParam)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/%s/%s/%s/changelog.md", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetProductionUsageRequest generates requests for GetProductionUsage
func NewGetProductionUsageRequest(server string, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoKindParam", runtime.ParamLocationPath, repoKindParam)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/%s/%s/%s/production-usage", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteProductionUsageRequest generates requests for DeleteProductionUsage
func NewDeleteProductionUsageRequest(server string, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam, orgName OrgNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoKindParam", runtime.ParamLocationPath, repoKindParam)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "orgName", runtime.ParamLocationPath, orgName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/%s/%s/%s/production-usage/$%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddProductionUsageRequest generates requests for AddProductionUsage
func NewAddProductionUsageRequest(server string, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam, orgName OrgNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoKindParam", runtime.ParamLocationPath, repoKindParam)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	var pathParam3 string

	pathParam3, err = runtime.StyleParamWithLocation("simple", false, "orgName", runtime.ParamLocationPath, orgName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/%s/%s/%s/production-usage/$%s", pathParam0, pathParam1, pathParam2, pathParam3)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPackageSummaryRequest generates requests for GetPackageSummary
func NewGetPackageSummaryRequest(server string, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoKindParam", runtime.ParamLocationPath, repoKindParam)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "packageName", runtime.ParamLocationPath, packageName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/packages/%s/%s/%s/summary", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddOrganizationRepositoryRequest calls the generic AddOrganizationRepository builder with application/json body
func NewAddOrganizationRepositoryRequest(server string, orgName OrgNameParam, body AddOrganizationRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOrganizationRepositoryRequestWithBody(server, orgName, "application/json", bodyReader)
}

// NewAddOrganizationRepositoryRequestWithBody generates requests for AddOrganizationRepository with any type of body
func NewAddOrganizationRepositoryRequestWithBody(server string, orgName OrgNameParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgName", runtime.ParamLocationPath, orgName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/org/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOrganizationRepositoryRequest generates requests for DeleteOrganizationRepository
func NewDeleteOrganizationRepositoryRequest(server string, orgName OrgNameParam, repoName RepoNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgName", runtime.ParamLocationPath, orgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/org/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOrganizationRepositoryRequest calls the generic UpdateOrganizationRepository builder with application/json body
func NewUpdateOrganizationRepositoryRequest(server string, orgName OrgNameParam, repoName RepoNameParam, body UpdateOrganizationRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOrganizationRepositoryRequestWithBody(server, orgName, repoName, "application/json", bodyReader)
}

// NewUpdateOrganizationRepositoryRequestWithBody generates requests for UpdateOrganizationRepository with any type of body
func NewUpdateOrganizationRepositoryRequestWithBody(server string, orgName OrgNameParam, repoName RepoNameParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgName", runtime.ParamLocationPath, orgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/org/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClaimRepositoryOwnershipFromOrganizationRequest generates requests for ClaimRepositoryOwnershipFromOrganization
func NewClaimRepositoryOwnershipFromOrganizationRequest(server string, orgName OrgNameParam, repoName RepoNameParam, params *ClaimRepositoryOwnershipFromOrganizationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgName", runtime.ParamLocationPath, orgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/org/%s/%s/claim-ownership", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Org != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTransferRepositoryOwnershipRequest generates requests for TransferRepositoryOwnership
func NewTransferRepositoryOwnershipRequest(server string, orgName OrgNameParam, repoName RepoNameParam, params *TransferRepositoryOwnershipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgName", runtime.ParamLocationPath, orgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/org/%s/%s/transfer", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Org != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchRepositoriesRequest generates requests for SearchRepositories
func NewSearchRepositoriesRequest(server string, params *SearchRepositoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/search")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Kind != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "kind", runtime.ParamLocationQuery, *params.Kind); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.User != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "user", runtime.ParamLocationQuery, *params.User); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Org != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Url != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, *params.Url); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddUserRepositoryRequest calls the generic AddUserRepository builder with application/json body
func NewAddUserRepositoryRequest(server string, body AddUserRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUserRepositoryRequestWithBody(server, "application/json", bodyReader)
}

// NewAddUserRepositoryRequestWithBody generates requests for AddUserRepository with any type of body
func NewAddUserRepositoryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserRepositoryRequest generates requests for DeleteUserRepository
func NewDeleteUserRepositoryRequest(server string, repoName RepoNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserRepositoryRequest calls the generic UpdateUserRepository builder with application/json body
func NewUpdateUserRepositoryRequest(server string, repoName RepoNameParam, body UpdateUserRepositoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserRepositoryRequestWithBody(server, repoName, "application/json", bodyReader)
}

// NewUpdateUserRepositoryRequestWithBody generates requests for UpdateUserRepository with any type of body
func NewUpdateUserRepositoryRequestWithBody(server string, repoName RepoNameParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewClaimRepositoryOwnershipRequest generates requests for ClaimRepositoryOwnership
func NewClaimRepositoryOwnershipRequest(server string, repoName RepoNameParam, params *ClaimRepositoryOwnershipParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/user/%s/claim-ownership", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Org != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTransferRepositoryOwnershipToOrganizationRequest generates requests for TransferRepositoryOwnershipToOrganization
func NewTransferRepositoryOwnershipToOrganizationRequest(server string, repoName RepoNameParam, params *TransferRepositoryOwnershipToOrganizationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "repoName", runtime.ParamLocationPath, repoName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/repositories/user/%s/transfer", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Org != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "org", runtime.ParamLocationQuery, *params.Org); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetArtifactHubStatsRequest generates requests for GetArtifactHubStats
func NewGetArtifactHubStatsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/stats")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeletePackageSubscriptionRequest generates requests for DeletePackageSubscription
func NewDeletePackageSubscriptionRequest(server string, params *DeletePackageSubscriptionParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "packageID", runtime.ParamLocationQuery, params.PackageID); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "event_kind", runtime.ParamLocationQuery, params.EventKind); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserSubscriptionsRequest generates requests for GetUserSubscriptions
func NewGetUserSubscriptionsRequest(server string, params *GetUserSubscriptionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddPackageSubscriptionRequest calls the generic AddPackageSubscription builder with application/json body
func NewAddPackageSubscriptionRequest(server string, body AddPackageSubscriptionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddPackageSubscriptionRequestWithBody(server, "application/json", bodyReader)
}

// NewAddPackageSubscriptionRequestWithBody generates requests for AddPackageSubscription with any type of body
func NewAddPackageSubscriptionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserOptOutEntriesRequest generates requests for GetUserOptOutEntries
func NewGetUserOptOutEntriesRequest(server string, params *GetUserOptOutEntriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions/opt-out")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddOptOutEntryRequest calls the generic AddOptOutEntry builder with application/json body
func NewAddOptOutEntryRequest(server string, body AddOptOutEntryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOptOutEntryRequestWithBody(server, "application/json", bodyReader)
}

// NewAddOptOutEntryRequestWithBody generates requests for AddOptOutEntry with any type of body
func NewAddOptOutEntryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions/opt-out")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOptOutEntryRequest generates requests for DeleteOptOutEntry
func NewDeleteOptOutEntryRequest(server string, optOutID OptOutIDParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "optOutID", runtime.ParamLocationPath, optOutID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions/opt-out/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPackageUserSubscriptionsRequest generates requests for GetPackageUserSubscriptions
func NewGetPackageUserSubscriptionsRequest(server string, packageID PackageIDParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "packageID", runtime.ParamLocationPath, packageID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/subscriptions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRegisterUserRequest calls the generic RegisterUser builder with application/json body
func NewRegisterUserRequest(server string, body RegisterUserJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRegisterUserRequestWithBody(server, "application/json", bodyReader)
}

// NewRegisterUserRequestWithBody generates requests for RegisterUser with any type of body
func NewRegisterUserRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateUserPasswordRequest calls the generic UpdateUserPassword builder with application/json body
func NewUpdateUserPasswordRequest(server string, body UpdateUserPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserPasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateUserPasswordRequestWithBody generates requests for UpdateUserPassword with any type of body
func NewUpdateUserPasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResetPasswordCodeRequest calls the generic ResetPasswordCode builder with application/json body
func NewResetPasswordCodeRequest(server string, body ResetPasswordCodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetPasswordCodeRequestWithBody(server, "application/json", bodyReader)
}

// NewResetPasswordCodeRequestWithBody generates requests for ResetPasswordCode with any type of body
func NewResetPasswordCodeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/password-reset-code")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserProfileRequest generates requests for GetUserProfile
func NewGetUserProfileRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/profile")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserProfileRequest calls the generic UpdateUserProfile builder with application/json body
func NewUpdateUserProfileRequest(server string, body UpdateUserProfileJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserProfileRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateUserProfileRequestWithBody generates requests for UpdateUserProfile with any type of body
func NewUpdateUserProfileRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/profile")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResetPasswordRequest calls the generic ResetPassword builder with application/json body
func NewResetPasswordRequest(server string, body ResetPasswordJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResetPasswordRequestWithBody(server, "application/json", bodyReader)
}

// NewResetPasswordRequestWithBody generates requests for ResetPassword with any type of body
func NewResetPasswordRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/reset-password")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVerifyEmailRequest calls the generic VerifyEmail builder with application/json body
func NewVerifyEmailRequest(server string, body VerifyEmailJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVerifyEmailRequestWithBody(server, "application/json", bodyReader)
}

// NewVerifyEmailRequestWithBody generates requests for VerifyEmail with any type of body
func NewVerifyEmailRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/verify-email")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewVerifyPasswordCodeRequest calls the generic VerifyPasswordCode builder with application/json body
func NewVerifyPasswordCodeRequest(server string, body VerifyPasswordCodeJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewVerifyPasswordCodeRequestWithBody(server, "application/json", bodyReader)
}

// NewVerifyPasswordCodeRequestWithBody generates requests for VerifyPasswordCode with any type of body
func NewVerifyPasswordCodeRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/verify-password-reset-code")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetOrganizationWebhooksRequest generates requests for GetOrganizationWebhooks
func NewGetOrganizationWebhooksRequest(server string, orgName OrgNameParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgName", runtime.ParamLocationPath, orgName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/org/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddOrganizationWebhookRequest calls the generic AddOrganizationWebhook builder with application/json body
func NewAddOrganizationWebhookRequest(server string, orgName OrgNameParam, body AddOrganizationWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddOrganizationWebhookRequestWithBody(server, orgName, "application/json", bodyReader)
}

// NewAddOrganizationWebhookRequestWithBody generates requests for AddOrganizationWebhook with any type of body
func NewAddOrganizationWebhookRequestWithBody(server string, orgName OrgNameParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgName", runtime.ParamLocationPath, orgName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/org/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteOrganizationWebhookRequest generates requests for DeleteOrganizationWebhook
func NewDeleteOrganizationWebhookRequest(server string, orgName OrgNameParam, webhookID WebhookIDParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgName", runtime.ParamLocationPath, orgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "webhookID", runtime.ParamLocationPath, webhookID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/org/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetOrganizationWebhookDetailsRequest generates requests for GetOrganizationWebhookDetails
func NewGetOrganizationWebhookDetailsRequest(server string, orgName OrgNameParam, webhookID WebhookIDParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgName", runtime.ParamLocationPath, orgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "webhookID", runtime.ParamLocationPath, webhookID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/org/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateOrganizationWebhookRequest calls the generic UpdateOrganizationWebhook builder with application/json body
func NewUpdateOrganizationWebhookRequest(server string, orgName OrgNameParam, webhookID WebhookIDParam, body UpdateOrganizationWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateOrganizationWebhookRequestWithBody(server, orgName, webhookID, "application/json", bodyReader)
}

// NewUpdateOrganizationWebhookRequestWithBody generates requests for UpdateOrganizationWebhook with any type of body
func NewUpdateOrganizationWebhookRequestWithBody(server string, orgName OrgNameParam, webhookID WebhookIDParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "orgName", runtime.ParamLocationPath, orgName)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "webhookID", runtime.ParamLocationPath, webhookID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/org/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewTriggerWebhookTestRequest calls the generic TriggerWebhookTest builder with application/json body
func NewTriggerWebhookTestRequest(server string, body TriggerWebhookTestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTriggerWebhookTestRequestWithBody(server, "application/json", bodyReader)
}

// NewTriggerWebhookTestRequestWithBody generates requests for TriggerWebhookTest with any type of body
func NewTriggerWebhookTestRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/test")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUserWebhooksRequest generates requests for GetUserWebhooks
func NewGetUserWebhooksRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewAddUserWebhookRequest calls the generic AddUserWebhook builder with application/json body
func NewAddUserWebhookRequest(server string, body AddUserWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddUserWebhookRequestWithBody(server, "application/json", bodyReader)
}

// NewAddUserWebhookRequestWithBody generates requests for AddUserWebhook with any type of body
func NewAddUserWebhookRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserWebhookRequest generates requests for DeleteUserWebhook
func NewDeleteUserWebhookRequest(server string, webhookID WebhookIDParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "webhookID", runtime.ParamLocationPath, webhookID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserWebhookDetailRequest generates requests for GetUserWebhookDetail
func NewGetUserWebhookDetailRequest(server string, webhookID WebhookIDParam) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "webhookID", runtime.ParamLocationPath, webhookID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateUserWebhookRequest calls the generic UpdateUserWebhook builder with application/json body
func NewUpdateUserWebhookRequest(server string, webhookID WebhookIDParam, body UpdateUserWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateUserWebhookRequestWithBody(server, webhookID, "application/json", bodyReader)
}

// NewUpdateUserWebhookRequestWithBody generates requests for UpdateUserWebhook with any type of body
func NewUpdateUserWebhookRequestWithBody(server string, webhookID WebhookIDParam, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "webhookID", runtime.ParamLocationPath, webhookID)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CheckAvailabilityWithResponse request
	CheckAvailabilityWithResponse(ctx context.Context, resourceKind ResourceKindNameParam, params *CheckAvailabilityParams, reqEditors ...RequestEditorFn) (*CheckAvailabilityResponse, error)

	// GetHarborReplicationDumpWithResponse request
	GetHarborReplicationDumpWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHarborReplicationDumpResponse, error)

	// GetHelmExporterDumpWithResponse request
	GetHelmExporterDumpWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHelmExporterDumpResponse, error)

	// GetNovaDumpWithResponse request
	GetNovaDumpWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNovaDumpResponse, error)

	// AddOrganizationWithBodyWithResponse request with any body
	AddOrganizationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationResponse, error)

	AddOrganizationWithResponse(ctx context.Context, body AddOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationResponse, error)

	// GetUserOrganizationsWithResponse request
	GetUserOrganizationsWithResponse(ctx context.Context, params *GetUserOrganizationsParams, reqEditors ...RequestEditorFn) (*GetUserOrganizationsResponse, error)

	// DeleteOrganizationWithResponse request
	DeleteOrganizationWithResponse(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*DeleteOrganizationResponse, error)

	// GetOrganizationProfileWithResponse request
	GetOrganizationProfileWithResponse(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*GetOrganizationProfileResponse, error)

	// UpdateOrganizationProfileWithBodyWithResponse request with any body
	UpdateOrganizationProfileWithBodyWithResponse(ctx context.Context, orgName OrgNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrganizationProfileResponse, error)

	UpdateOrganizationProfileWithResponse(ctx context.Context, orgName OrgNameParam, body UpdateOrganizationProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrganizationProfileResponse, error)

	// AcceptOrganizationInvitationWithResponse request
	AcceptOrganizationInvitationWithResponse(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*AcceptOrganizationInvitationResponse, error)

	// GetOrganizationAuthPolicyWithResponse request
	GetOrganizationAuthPolicyWithResponse(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*GetOrganizationAuthPolicyResponse, error)

	// UpdateOrganizationAuthPolicyWithBodyWithResponse request with any body
	UpdateOrganizationAuthPolicyWithBodyWithResponse(ctx context.Context, orgName OrgNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrganizationAuthPolicyResponse, error)

	UpdateOrganizationAuthPolicyWithResponse(ctx context.Context, orgName OrgNameParam, body UpdateOrganizationAuthPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrganizationAuthPolicyResponse, error)

	// DeleteOrganizationMemberWithResponse request
	DeleteOrganizationMemberWithResponse(ctx context.Context, orgName OrgNameParam, userAlias UserAliasParam, reqEditors ...RequestEditorFn) (*DeleteOrganizationMemberResponse, error)

	// AddOrganizationMemberWithResponse request
	AddOrganizationMemberWithResponse(ctx context.Context, orgName OrgNameParam, userAlias UserAliasParam, reqEditors ...RequestEditorFn) (*AddOrganizationMemberResponse, error)

	// GetOrganizationMembersWithResponse request
	GetOrganizationMembersWithResponse(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*GetOrganizationMembersResponse, error)

	// GetAllowedActionsWithResponse request
	GetAllowedActionsWithResponse(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*GetAllowedActionsResponse, error)

	// GetArgoTemplatesDetailsWithResponse request
	GetArgoTemplatesDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetArgoTemplatesDetailsResponse, error)

	// GetArgoTemplatesVersionDetailsWithResponse request
	GetArgoTemplatesVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetArgoTemplatesVersionDetailsResponse, error)

	// GetBackstagePluginsDetailsWithResponse request
	GetBackstagePluginsDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetBackstagePluginsDetailsResponse, error)

	// GetBackstagePluginsVersionDetailsWithResponse request
	GetBackstagePluginsVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetBackstagePluginsVersionDetailsResponse, error)

	// GetContainerImageDetailsWithResponse request
	GetContainerImageDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetContainerImageDetailsResponse, error)

	// GetContainerImageVersionDetailsWithResponse request
	GetContainerImageVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetContainerImageVersionDetailsResponse, error)

	// GetCoreDNSPluginDetailsWithResponse request
	GetCoreDNSPluginDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetCoreDNSPluginDetailsResponse, error)

	// GetCoreDNSPluginVersionDetailsWithResponse request
	GetCoreDNSPluginVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetCoreDNSPluginVersionDetailsResponse, error)

	// GetFalcoRulesDetailsWithResponse request
	GetFalcoRulesDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetFalcoRulesDetailsResponse, error)

	// GetFalcoRulesVersionDetailsWithResponse request
	GetFalcoRulesVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetFalcoRulesVersionDetailsResponse, error)

	// GetGatekeeperPoliciesDetailsWithResponse request
	GetGatekeeperPoliciesDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetGatekeeperPoliciesDetailsResponse, error)

	// GetGatekeeperPoliciesVersionDetailsWithResponse request
	GetGatekeeperPoliciesVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetGatekeeperPoliciesVersionDetailsResponse, error)

	// GetHelmPluginDetailsWithResponse request
	GetHelmPluginDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetHelmPluginDetailsResponse, error)

	// GetHelmPluginVersionDetailsWithResponse request
	GetHelmPluginVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetHelmPluginVersionDetailsResponse, error)

	// GetHelmPackageDetailsWithResponse request
	GetHelmPackageDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetHelmPackageDetailsResponse, error)

	// GetHelmPackageVersionDetailsWithResponse request
	GetHelmPackageVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetHelmPackageVersionDetailsResponse, error)

	// GetKedaScalerDetailsWithResponse request
	GetKedaScalerDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetKedaScalerDetailsResponse, error)

	// GetKedaScalerVersionDetailsWithResponse request
	GetKedaScalerVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetKedaScalerVersionDetailsResponse, error)

	// GetKeptnIntegrationsDetailsWithResponse request
	GetKeptnIntegrationsDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetKeptnIntegrationsDetailsResponse, error)

	// GetKeptnIntegrationsVersionDetailsWithResponse request
	GetKeptnIntegrationsVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetKeptnIntegrationsVersionDetailsResponse, error)

	// GetKnativeClientPluginIntegrationsDetailsWithResponse request
	GetKnativeClientPluginIntegrationsDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetKnativeClientPluginIntegrationsDetailsResponse, error)

	// GetKnativeClientPluginsVersionDetailsWithResponse request
	GetKnativeClientPluginsVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetKnativeClientPluginsVersionDetailsResponse, error)

	// GetKubectlPluginDetailsWithResponse request
	GetKubectlPluginDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetKubectlPluginDetailsResponse, error)

	// GetKubectlPluginVersionDetailsWithResponse request
	GetKubectlPluginVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetKubectlPluginVersionDetailsResponse, error)

	// GetKubeArmorPoliciesDetailsWithResponse request
	GetKubeArmorPoliciesDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetKubeArmorPoliciesDetailsResponse, error)

	// GetKubeArmorPoliciesVersionDetailsWithResponse request
	GetKubeArmorPoliciesVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetKubeArmorPoliciesVersionDetailsResponse, error)

	// GetKubewardenPoliciesDetailsWithResponse request
	GetKubewardenPoliciesDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetKubewardenPoliciesDetailsResponse, error)

	// GetKubewardenPoliciesVersionDetailsWithResponse request
	GetKubewardenPoliciesVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetKubewardenPoliciesVersionDetailsResponse, error)

	// GetKyvernoPoliciesDetailsWithResponse request
	GetKyvernoPoliciesDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetKyvernoPoliciesDetailsResponse, error)

	// GetKyvernoPoliciesVersionDetailsWithResponse request
	GetKyvernoPoliciesVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetKyvernoPoliciesVersionDetailsResponse, error)

	// GetOLMOperatorDetailsWithResponse request
	GetOLMOperatorDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetOLMOperatorDetailsResponse, error)

	// GetOLMOperatorVersionDetailsWithResponse request
	GetOLMOperatorVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetOLMOperatorVersionDetailsResponse, error)

	// GetOPAPoliciesDetailsWithResponse request
	GetOPAPoliciesDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetOPAPoliciesDetailsResponse, error)

	// GetOPAPoliciesVersionDetailsWithResponse request
	GetOPAPoliciesVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetOPAPoliciesVersionDetailsResponse, error)

	// GetRandomPackagesWithResponse request
	GetRandomPackagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRandomPackagesResponse, error)

	// SearchPackagesWithResponse request
	SearchPackagesWithResponse(ctx context.Context, params *SearchPackagesParams, reqEditors ...RequestEditorFn) (*SearchPackagesResponse, error)

	// GetStarredPackagesByUserWithResponse request
	GetStarredPackagesByUserWithResponse(ctx context.Context, params *GetStarredPackagesByUserParams, reqEditors ...RequestEditorFn) (*GetStarredPackagesByUserResponse, error)

	// GetPackageStatsWithResponse request
	GetPackageStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPackageStatsResponse, error)

	// GetTinkerbellActionsDetailsWithResponse request
	GetTinkerbellActionsDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetTinkerbellActionsDetailsResponse, error)

	// GetTinkerbellActionsVersionDetailsWithResponse request
	GetTinkerbellActionsVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetTinkerbellActionsVersionDetailsResponse, error)

	// GetTektonPipelineDetailsWithResponse request
	GetTektonPipelineDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetTektonPipelineDetailsResponse, error)

	// GetTektonPipelineVersionDetailsWithResponse request
	GetTektonPipelineVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetTektonPipelineVersionDetailsResponse, error)

	// GetTektonTaskDetailsWithResponse request
	GetTektonTaskDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetTektonTaskDetailsResponse, error)

	// GetTektonTaskVersionDetailsWithResponse request
	GetTektonTaskVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetTektonTaskVersionDetailsResponse, error)

	// GetPackageChangelogWithResponse request
	GetPackageChangelogWithResponse(ctx context.Context, packageID PackageIDParam, reqEditors ...RequestEditorFn) (*GetPackageChangelogResponse, error)

	// GetPackageStarsWithResponse request
	GetPackageStarsWithResponse(ctx context.Context, packageID PackageIDParam, reqEditors ...RequestEditorFn) (*GetPackageStarsResponse, error)

	// TogglePackageStarWithResponse request
	TogglePackageStarWithResponse(ctx context.Context, packageID PackageIDParam, reqEditors ...RequestEditorFn) (*TogglePackageStarResponse, error)

	// GetPackageViewsWithResponse request
	GetPackageViewsWithResponse(ctx context.Context, packageID PackageIDParam, reqEditors ...RequestEditorFn) (*GetPackageViewsResponse, error)

	// GetPackageSecurityReportWithResponse request
	GetPackageSecurityReportWithResponse(ctx context.Context, packageID PackageIDParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetPackageSecurityReportResponse, error)

	// GetHelmChartTemplatesWithResponse request
	GetHelmChartTemplatesWithResponse(ctx context.Context, packageID PackageIDParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetHelmChartTemplatesResponse, error)

	// GetChartValuesWithResponse request
	GetChartValuesWithResponse(ctx context.Context, packageID PackageIDParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetChartValuesResponse, error)

	// GetPackageValuesSchemaWithResponse request
	GetPackageValuesSchemaWithResponse(ctx context.Context, packageID PackageIDParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetPackageValuesSchemaResponse, error)

	// GenerateChangelogMDWithResponse request
	GenerateChangelogMDWithResponse(ctx context.Context, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GenerateChangelogMDResponse, error)

	// GetProductionUsageWithResponse request
	GetProductionUsageWithResponse(ctx context.Context, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetProductionUsageResponse, error)

	// DeleteProductionUsageWithResponse request
	DeleteProductionUsageWithResponse(ctx context.Context, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*DeleteProductionUsageResponse, error)

	// AddProductionUsageWithResponse request
	AddProductionUsageWithResponse(ctx context.Context, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*AddProductionUsageResponse, error)

	// GetPackageSummaryWithResponse request
	GetPackageSummaryWithResponse(ctx context.Context, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetPackageSummaryResponse, error)

	// AddOrganizationRepositoryWithBodyWithResponse request with any body
	AddOrganizationRepositoryWithBodyWithResponse(ctx context.Context, orgName OrgNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationRepositoryResponse, error)

	AddOrganizationRepositoryWithResponse(ctx context.Context, orgName OrgNameParam, body AddOrganizationRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationRepositoryResponse, error)

	// DeleteOrganizationRepositoryWithResponse request
	DeleteOrganizationRepositoryWithResponse(ctx context.Context, orgName OrgNameParam, repoName RepoNameParam, reqEditors ...RequestEditorFn) (*DeleteOrganizationRepositoryResponse, error)

	// UpdateOrganizationRepositoryWithBodyWithResponse request with any body
	UpdateOrganizationRepositoryWithBodyWithResponse(ctx context.Context, orgName OrgNameParam, repoName RepoNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrganizationRepositoryResponse, error)

	UpdateOrganizationRepositoryWithResponse(ctx context.Context, orgName OrgNameParam, repoName RepoNameParam, body UpdateOrganizationRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrganizationRepositoryResponse, error)

	// ClaimRepositoryOwnershipFromOrganizationWithResponse request
	ClaimRepositoryOwnershipFromOrganizationWithResponse(ctx context.Context, orgName OrgNameParam, repoName RepoNameParam, params *ClaimRepositoryOwnershipFromOrganizationParams, reqEditors ...RequestEditorFn) (*ClaimRepositoryOwnershipFromOrganizationResponse, error)

	// TransferRepositoryOwnershipWithResponse request
	TransferRepositoryOwnershipWithResponse(ctx context.Context, orgName OrgNameParam, repoName RepoNameParam, params *TransferRepositoryOwnershipParams, reqEditors ...RequestEditorFn) (*TransferRepositoryOwnershipResponse, error)

	// SearchRepositoriesWithResponse request
	SearchRepositoriesWithResponse(ctx context.Context, params *SearchRepositoriesParams, reqEditors ...RequestEditorFn) (*SearchRepositoriesResponse, error)

	// AddUserRepositoryWithBodyWithResponse request with any body
	AddUserRepositoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserRepositoryResponse, error)

	AddUserRepositoryWithResponse(ctx context.Context, body AddUserRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserRepositoryResponse, error)

	// DeleteUserRepositoryWithResponse request
	DeleteUserRepositoryWithResponse(ctx context.Context, repoName RepoNameParam, reqEditors ...RequestEditorFn) (*DeleteUserRepositoryResponse, error)

	// UpdateUserRepositoryWithBodyWithResponse request with any body
	UpdateUserRepositoryWithBodyWithResponse(ctx context.Context, repoName RepoNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserRepositoryResponse, error)

	UpdateUserRepositoryWithResponse(ctx context.Context, repoName RepoNameParam, body UpdateUserRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserRepositoryResponse, error)

	// ClaimRepositoryOwnershipWithResponse request
	ClaimRepositoryOwnershipWithResponse(ctx context.Context, repoName RepoNameParam, params *ClaimRepositoryOwnershipParams, reqEditors ...RequestEditorFn) (*ClaimRepositoryOwnershipResponse, error)

	// TransferRepositoryOwnershipToOrganizationWithResponse request
	TransferRepositoryOwnershipToOrganizationWithResponse(ctx context.Context, repoName RepoNameParam, params *TransferRepositoryOwnershipToOrganizationParams, reqEditors ...RequestEditorFn) (*TransferRepositoryOwnershipToOrganizationResponse, error)

	// GetArtifactHubStatsWithResponse request
	GetArtifactHubStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetArtifactHubStatsResponse, error)

	// DeletePackageSubscriptionWithResponse request
	DeletePackageSubscriptionWithResponse(ctx context.Context, params *DeletePackageSubscriptionParams, reqEditors ...RequestEditorFn) (*DeletePackageSubscriptionResponse, error)

	// GetUserSubscriptionsWithResponse request
	GetUserSubscriptionsWithResponse(ctx context.Context, params *GetUserSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetUserSubscriptionsResponse, error)

	// AddPackageSubscriptionWithBodyWithResponse request with any body
	AddPackageSubscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPackageSubscriptionResponse, error)

	AddPackageSubscriptionWithResponse(ctx context.Context, body AddPackageSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPackageSubscriptionResponse, error)

	// GetUserOptOutEntriesWithResponse request
	GetUserOptOutEntriesWithResponse(ctx context.Context, params *GetUserOptOutEntriesParams, reqEditors ...RequestEditorFn) (*GetUserOptOutEntriesResponse, error)

	// AddOptOutEntryWithBodyWithResponse request with any body
	AddOptOutEntryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOptOutEntryResponse, error)

	AddOptOutEntryWithResponse(ctx context.Context, body AddOptOutEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOptOutEntryResponse, error)

	// DeleteOptOutEntryWithResponse request
	DeleteOptOutEntryWithResponse(ctx context.Context, optOutID OptOutIDParam, reqEditors ...RequestEditorFn) (*DeleteOptOutEntryResponse, error)

	// GetPackageUserSubscriptionsWithResponse request
	GetPackageUserSubscriptionsWithResponse(ctx context.Context, packageID PackageIDParam, reqEditors ...RequestEditorFn) (*GetPackageUserSubscriptionsResponse, error)

	// RegisterUserWithBodyWithResponse request with any body
	RegisterUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterUserResponse, error)

	RegisterUserWithResponse(ctx context.Context, body RegisterUserJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterUserResponse, error)

	// UpdateUserPasswordWithBodyWithResponse request with any body
	UpdateUserPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserPasswordResponse, error)

	UpdateUserPasswordWithResponse(ctx context.Context, body UpdateUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserPasswordResponse, error)

	// ResetPasswordCodeWithBodyWithResponse request with any body
	ResetPasswordCodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordCodeResponse, error)

	ResetPasswordCodeWithResponse(ctx context.Context, body ResetPasswordCodeJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordCodeResponse, error)

	// GetUserProfileWithResponse request
	GetUserProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserProfileResponse, error)

	// UpdateUserProfileWithBodyWithResponse request with any body
	UpdateUserProfileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserProfileResponse, error)

	UpdateUserProfileWithResponse(ctx context.Context, body UpdateUserProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserProfileResponse, error)

	// ResetPasswordWithBodyWithResponse request with any body
	ResetPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	ResetPasswordWithResponse(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error)

	// VerifyEmailWithBodyWithResponse request with any body
	VerifyEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VerifyEmailResponse, error)

	VerifyEmailWithResponse(ctx context.Context, body VerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*VerifyEmailResponse, error)

	// VerifyPasswordCodeWithBodyWithResponse request with any body
	VerifyPasswordCodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VerifyPasswordCodeResponse, error)

	VerifyPasswordCodeWithResponse(ctx context.Context, body VerifyPasswordCodeJSONRequestBody, reqEditors ...RequestEditorFn) (*VerifyPasswordCodeResponse, error)

	// GetOrganizationWebhooksWithResponse request
	GetOrganizationWebhooksWithResponse(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*GetOrganizationWebhooksResponse, error)

	// AddOrganizationWebhookWithBodyWithResponse request with any body
	AddOrganizationWebhookWithBodyWithResponse(ctx context.Context, orgName OrgNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationWebhookResponse, error)

	AddOrganizationWebhookWithResponse(ctx context.Context, orgName OrgNameParam, body AddOrganizationWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationWebhookResponse, error)

	// DeleteOrganizationWebhookWithResponse request
	DeleteOrganizationWebhookWithResponse(ctx context.Context, orgName OrgNameParam, webhookID WebhookIDParam, reqEditors ...RequestEditorFn) (*DeleteOrganizationWebhookResponse, error)

	// GetOrganizationWebhookDetailsWithResponse request
	GetOrganizationWebhookDetailsWithResponse(ctx context.Context, orgName OrgNameParam, webhookID WebhookIDParam, reqEditors ...RequestEditorFn) (*GetOrganizationWebhookDetailsResponse, error)

	// UpdateOrganizationWebhookWithBodyWithResponse request with any body
	UpdateOrganizationWebhookWithBodyWithResponse(ctx context.Context, orgName OrgNameParam, webhookID WebhookIDParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrganizationWebhookResponse, error)

	UpdateOrganizationWebhookWithResponse(ctx context.Context, orgName OrgNameParam, webhookID WebhookIDParam, body UpdateOrganizationWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrganizationWebhookResponse, error)

	// TriggerWebhookTestWithBodyWithResponse request with any body
	TriggerWebhookTestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TriggerWebhookTestResponse, error)

	TriggerWebhookTestWithResponse(ctx context.Context, body TriggerWebhookTestJSONRequestBody, reqEditors ...RequestEditorFn) (*TriggerWebhookTestResponse, error)

	// GetUserWebhooksWithResponse request
	GetUserWebhooksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserWebhooksResponse, error)

	// AddUserWebhookWithBodyWithResponse request with any body
	AddUserWebhookWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserWebhookResponse, error)

	AddUserWebhookWithResponse(ctx context.Context, body AddUserWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserWebhookResponse, error)

	// DeleteUserWebhookWithResponse request
	DeleteUserWebhookWithResponse(ctx context.Context, webhookID WebhookIDParam, reqEditors ...RequestEditorFn) (*DeleteUserWebhookResponse, error)

	// GetUserWebhookDetailWithResponse request
	GetUserWebhookDetailWithResponse(ctx context.Context, webhookID WebhookIDParam, reqEditors ...RequestEditorFn) (*GetUserWebhookDetailResponse, error)

	// UpdateUserWebhookWithBodyWithResponse request with any body
	UpdateUserWebhookWithBodyWithResponse(ctx context.Context, webhookID WebhookIDParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserWebhookResponse, error)

	UpdateUserWebhookWithResponse(ctx context.Context, webhookID WebhookIDParam, body UpdateUserWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserWebhookResponse, error)
}

type CheckAvailabilityResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r CheckAvailabilityResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckAvailabilityResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHarborReplicationDumpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]map[string]interface{}
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetHarborReplicationDumpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHarborReplicationDumpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHelmExporterDumpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]map[string]interface{}
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetHelmExporterDumpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHelmExporterDumpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNovaDumpResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]map[string]interface{}
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetNovaDumpResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNovaDumpResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *UnauthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AddOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserOrganizationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Organization
	JSON401      *UnauthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserOrganizationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserOrganizationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OrganizationSummary
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOrganizationProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOrganizationProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateOrganizationProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOrganizationProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AcceptOrganizationInvitationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AcceptOrganizationInvitationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AcceptOrganizationInvitationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationAuthPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthorizationPolicy
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOrganizationAuthPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationAuthPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOrganizationAuthPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateOrganizationAuthPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOrganizationAuthPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrganizationMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteOrganizationMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrganizationMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOrganizationMemberResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AddOrganizationMemberResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOrganizationMemberResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationMembersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Member
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOrganizationMembersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationMembersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAllowedActionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]AuthorizerAction
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetAllowedActionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAllowedActionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArgoTemplatesDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArgoTemplate
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetArgoTemplatesDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArgoTemplatesDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArgoTemplatesVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ArgoTemplate
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetArgoTemplatesVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArgoTemplatesVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackstagePluginsDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackstagePlugin
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetBackstagePluginsDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackstagePluginsDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackstagePluginsVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *BackstagePlugin
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetBackstagePluginsVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackstagePluginsVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContainerImageDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContainerImage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetContainerImageDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContainerImageDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetContainerImageVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ContainerImage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetContainerImageVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetContainerImageVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCoreDNSPluginDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoreDNSPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCoreDNSPluginDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoreDNSPluginDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCoreDNSPluginVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoreDNSPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetCoreDNSPluginVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoreDNSPluginVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFalcoRulesDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FalcoPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetFalcoRulesDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFalcoRulesDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFalcoRulesVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FalcoPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetFalcoRulesVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFalcoRulesVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGatekeeperPoliciesDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GatekeeperPolicy
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGatekeeperPoliciesDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGatekeeperPoliciesDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGatekeeperPoliciesVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GatekeeperPolicy
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetGatekeeperPoliciesVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGatekeeperPoliciesVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHelmPluginDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HelmPluginPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetHelmPluginDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHelmPluginDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHelmPluginVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HelmPluginPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetHelmPluginVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHelmPluginVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHelmPackageDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HelmPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetHelmPackageDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHelmPackageDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHelmPackageVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *HelmPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetHelmPackageVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHelmPackageVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKedaScalerDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KedaScalerPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetKedaScalerDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKedaScalerDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKedaScalerVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KedaScalerPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetKedaScalerVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKedaScalerVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeptnIntegrationsDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeptnIntegrationsPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetKeptnIntegrationsDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeptnIntegrationsDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKeptnIntegrationsVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KeptnIntegrationsPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetKeptnIntegrationsVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKeptnIntegrationsVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKnativeClientPluginIntegrationsDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KnativeClientPluginsPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetKnativeClientPluginIntegrationsDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKnativeClientPluginIntegrationsDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKnativeClientPluginsVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KnativeClientPluginsPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetKnativeClientPluginsVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKnativeClientPluginsVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKubectlPluginDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KrewPluginsPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetKubectlPluginDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKubectlPluginDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKubectlPluginVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KrewPluginsPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetKubectlPluginVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKubectlPluginVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKubeArmorPoliciesDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KubeArmorPoliciesPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetKubeArmorPoliciesDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKubeArmorPoliciesDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKubeArmorPoliciesVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KubeArmorPoliciesPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetKubeArmorPoliciesVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKubeArmorPoliciesVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKubewardenPoliciesDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KubewardenPoliciesPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetKubewardenPoliciesDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKubewardenPoliciesDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKubewardenPoliciesVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KubewardenPoliciesPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetKubewardenPoliciesVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKubewardenPoliciesVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKyvernoPoliciesDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KyvernoPolicy
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetKyvernoPoliciesDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKyvernoPoliciesDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetKyvernoPoliciesVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *KyvernoPolicy
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetKyvernoPoliciesVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetKyvernoPoliciesVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOLMOperatorDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OLMPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOLMOperatorDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOLMOperatorDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOLMOperatorVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OLMPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOLMOperatorVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOLMOperatorVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOPAPoliciesDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OPAPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOPAPoliciesDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOPAPoliciesDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOPAPoliciesVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *OPAPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOPAPoliciesVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOPAPoliciesVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRandomPackagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PackageSummary
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetRandomPackagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRandomPackagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchPackagesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Facets   *[]Facets         `json:"facets,omitempty"`
		Packages *[]PackageSummary `json:"packages,omitempty"`
	}
	JSON400 *BadRequest
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchPackagesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchPackagesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStarredPackagesByUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]PackageSummary
	JSON401      *UnauthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetStarredPackagesByUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStarredPackagesByUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackageStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Packages *int `json:"packages,omitempty"`
		Releases *int `json:"releases,omitempty"`
	}
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPackageStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackageStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTinkerbellActionsDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TBActionPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetTinkerbellActionsDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTinkerbellActionsDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTinkerbellActionsVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TBActionPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetTinkerbellActionsVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTinkerbellActionsVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTektonPipelineDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TektonPipelinePackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetTektonPipelineDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTektonPipelineDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTektonPipelineVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TektonPipelinePackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetTektonPipelineVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTektonPipelineVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTektonTaskDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TektonTaskPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetTektonTaskDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTektonTaskDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTektonTaskVersionDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TektonTaskPackage
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetTektonTaskVersionDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTektonTaskVersionDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackageChangelogResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		Changes *[]struct {
			Description string `json:"description"`

			// Kind Types of changes:
			//   * `added` - New features
			//   * `changed` - Changes in existing functionality
			//   * `deprecated` - Soon-to-be removed features
			//   * `removed` - Removed features
			//   * `fixed` - Any bug fixed
			//   * `security` - In case of vulnerabilities
			Kind  *ChangelogItemKind `json:"kind,omitempty"`
			Links *[]struct {
				Name string `json:"name"`
				Url  string `json:"url"`
			} `json:"links,omitempty"`
		} `json:"changes,omitempty"`
		ContainsSecurityUpdates bool   `json:"contains_security_updates"`
		Prerelease              bool   `json:"prerelease"`
		Ts                      int    `json:"ts"`
		Version                 string `json:"version"`
	}
	JSON404 *NotFoundResponse
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPackageChangelogResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackageChangelogResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackageStarsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		StarredByUser *bool `json:"starred_by_user,omitempty"`
		Stars         *int  `json:"stars,omitempty"`
	}
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPackageStarsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackageStarsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TogglePackageStarResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r TogglePackageStarResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TogglePackageStarResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackageViewsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON400      *BadRequest
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPackageViewsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackageViewsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackageSecurityReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPackageSecurityReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackageSecurityReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetHelmChartTemplatesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Templates []struct {
			Data []byte `json:"data"`
			Name string `json:"name"`
		} `json:"templates"`
		Values map[string]interface{} `json:"values"`
	}
	JSON400 *BadRequest
	JSON404 *NotFoundResponse
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetHelmChartTemplatesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetHelmChartTemplatesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChartValuesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	YAML200      *string
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetChartValuesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChartValuesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackageValuesSchemaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPackageValuesSchemaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackageValuesSchemaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GenerateChangelogMDResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GenerateChangelogMDResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GenerateChangelogMDResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetProductionUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetProductionUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetProductionUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteProductionUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteProductionUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteProductionUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddProductionUsageResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AddProductionUsageResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddProductionUsageResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackageSummaryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PackageSummary
	JSON404      *NotFoundResponse
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPackageSummaryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackageSummaryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOrganizationRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AddOrganizationRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOrganizationRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrganizationRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteOrganizationRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrganizationRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOrganizationRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateOrganizationRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOrganizationRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClaimRepositoryOwnershipFromOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ClaimRepositoryOwnershipFromOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClaimRepositoryOwnershipFromOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferRepositoryOwnershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r TransferRepositoryOwnershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferRepositoryOwnershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchRepositoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Repository
	JSON401      *UnauthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r SearchRepositoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchRepositoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUserRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *UnauthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AddUserRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUserRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteUserRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserRepositoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateUserRepositoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserRepositoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ClaimRepositoryOwnershipResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ClaimRepositoryOwnershipResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ClaimRepositoryOwnershipResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TransferRepositoryOwnershipToOrganizationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r TransferRepositoryOwnershipToOrganizationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TransferRepositoryOwnershipToOrganizationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetArtifactHubStatsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		GeneratedAt   int `json:"generated_at"`
		Organizations struct {
			RunningTotal *[][]int `json:"running_total,omitempty"`
			Total        int      `json:"total"`
		} `json:"organizations"`
		Packages struct {
			CreatedMonthly *[][]int `json:"created_monthly,omitempty"`
			RunningTotal   *[][]int `json:"running_total,omitempty"`
			Total          int      `json:"total"`
			ViewsDaily     *[][]int `json:"views_daily,omitempty"`
		} `json:"packages"`
		Repositories struct {
			CreatedMonthly *[][]int `json:"created_monthly,omitempty"`
			RunningTotal   *[][]int `json:"running_total,omitempty"`
			Total          int      `json:"total"`
		} `json:"repositories"`
		Snapshots struct {
			CreatedMonthly *[][]int `json:"created_monthly,omitempty"`
			RunningTotal   *[][]int `json:"running_total,omitempty"`
			Total          int      `json:"total"`
		} `json:"snapshots"`
		Users struct {
			RunningTotal *[][]int `json:"running_total,omitempty"`
			Total        int      `json:"total"`
		} `json:"users"`
	}
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetArtifactHubStatsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetArtifactHubStatsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePackageSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeletePackageSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePackageSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		EventKinds     []EventKindId      `json:"event_kinds"`
		LogoImageId    *string            `json:"logo_image_id,omitempty"`
		Name           string             `json:"name"`
		NormalizedName string             `json:"normalized_name"`
		PackageId      openapi_types.UUID `json:"package_id"`
		Repository     RepositorySummary  `json:"repository"`
	}
	JSON401 *UnauthorizedError
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddPackageSubscriptionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AddPackageSubscriptionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddPackageSubscriptionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserOptOutEntriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// EventKind Event kind:
		//   * `0` - New package release
		//   * `1` - Security alerts
		//   * `2` - Repository tracking errors
		//   * `4` - Repository scanning errors
		EventKind  EventKindId        `json:"event_kind"`
		OptOutId   openapi_types.UUID `json:"opt_out_id"`
		Repository RepositorySummary  `json:"repository"`
	}
	JSON401 *UnauthorizedError
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserOptOutEntriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserOptOutEntriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOptOutEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AddOptOutEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOptOutEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOptOutEntryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteOptOutEntryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOptOutEntryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPackageUserSubscriptionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]struct {
		// EventKind Event kind:
		//   * `0` - New package release
		//   * `1` - Security alerts
		//   * `2` - Repository tracking errors
		//   * `4` - Repository scanning errors
		EventKind EventKindId `json:"event_kind"`
	}
	JSON401 *UnauthorizedError
	JSON500 *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetPackageUserSubscriptionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPackageUserSubscriptionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RegisterUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r RegisterUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RegisterUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *UnauthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateUserPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetPasswordCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ResetPasswordCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetPasswordCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *User
	JSON401      *UnauthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserProfileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *UnauthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateUserProfileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserProfileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResetPasswordResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ResetPasswordResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResetPasswordResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VerifyEmailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *UnauthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r VerifyEmailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VerifyEmailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type VerifyPasswordCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r VerifyPasswordCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r VerifyPasswordCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationWebhooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Webhook
	JSON401      *UnauthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOrganizationWebhooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationWebhooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddOrganizationWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AddOrganizationWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddOrganizationWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteOrganizationWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteOrganizationWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteOrganizationWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetOrganizationWebhookDetailsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Webhook
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetOrganizationWebhookDetailsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetOrganizationWebhookDetailsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateOrganizationWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *UnauthorizedError
	JSON403      *Forbidden
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateOrganizationWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateOrganizationWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TriggerWebhookTestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *UnauthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r TriggerWebhookTestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TriggerWebhookTestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserWebhooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]Webhook
	JSON401      *UnauthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserWebhooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserWebhooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddUserWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *UnauthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r AddUserWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddUserWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *UnauthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r DeleteUserWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserWebhookDetailResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Webhook
	JSON401      *UnauthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r GetUserWebhookDetailResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserWebhookDetailResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateUserWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON401      *UnauthorizedError
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r UpdateUserWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateUserWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CheckAvailabilityWithResponse request returning *CheckAvailabilityResponse
func (c *ClientWithResponses) CheckAvailabilityWithResponse(ctx context.Context, resourceKind ResourceKindNameParam, params *CheckAvailabilityParams, reqEditors ...RequestEditorFn) (*CheckAvailabilityResponse, error) {
	rsp, err := c.CheckAvailability(ctx, resourceKind, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckAvailabilityResponse(rsp)
}

// GetHarborReplicationDumpWithResponse request returning *GetHarborReplicationDumpResponse
func (c *ClientWithResponses) GetHarborReplicationDumpWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHarborReplicationDumpResponse, error) {
	rsp, err := c.GetHarborReplicationDump(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHarborReplicationDumpResponse(rsp)
}

// GetHelmExporterDumpWithResponse request returning *GetHelmExporterDumpResponse
func (c *ClientWithResponses) GetHelmExporterDumpWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetHelmExporterDumpResponse, error) {
	rsp, err := c.GetHelmExporterDump(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHelmExporterDumpResponse(rsp)
}

// GetNovaDumpWithResponse request returning *GetNovaDumpResponse
func (c *ClientWithResponses) GetNovaDumpWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetNovaDumpResponse, error) {
	rsp, err := c.GetNovaDump(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNovaDumpResponse(rsp)
}

// AddOrganizationWithBodyWithResponse request with arbitrary body returning *AddOrganizationResponse
func (c *ClientWithResponses) AddOrganizationWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationResponse, error) {
	rsp, err := c.AddOrganizationWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationResponse(rsp)
}

func (c *ClientWithResponses) AddOrganizationWithResponse(ctx context.Context, body AddOrganizationJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationResponse, error) {
	rsp, err := c.AddOrganization(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationResponse(rsp)
}

// GetUserOrganizationsWithResponse request returning *GetUserOrganizationsResponse
func (c *ClientWithResponses) GetUserOrganizationsWithResponse(ctx context.Context, params *GetUserOrganizationsParams, reqEditors ...RequestEditorFn) (*GetUserOrganizationsResponse, error) {
	rsp, err := c.GetUserOrganizations(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserOrganizationsResponse(rsp)
}

// DeleteOrganizationWithResponse request returning *DeleteOrganizationResponse
func (c *ClientWithResponses) DeleteOrganizationWithResponse(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*DeleteOrganizationResponse, error) {
	rsp, err := c.DeleteOrganization(ctx, orgName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrganizationResponse(rsp)
}

// GetOrganizationProfileWithResponse request returning *GetOrganizationProfileResponse
func (c *ClientWithResponses) GetOrganizationProfileWithResponse(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*GetOrganizationProfileResponse, error) {
	rsp, err := c.GetOrganizationProfile(ctx, orgName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationProfileResponse(rsp)
}

// UpdateOrganizationProfileWithBodyWithResponse request with arbitrary body returning *UpdateOrganizationProfileResponse
func (c *ClientWithResponses) UpdateOrganizationProfileWithBodyWithResponse(ctx context.Context, orgName OrgNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrganizationProfileResponse, error) {
	rsp, err := c.UpdateOrganizationProfileWithBody(ctx, orgName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrganizationProfileResponse(rsp)
}

func (c *ClientWithResponses) UpdateOrganizationProfileWithResponse(ctx context.Context, orgName OrgNameParam, body UpdateOrganizationProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrganizationProfileResponse, error) {
	rsp, err := c.UpdateOrganizationProfile(ctx, orgName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrganizationProfileResponse(rsp)
}

// AcceptOrganizationInvitationWithResponse request returning *AcceptOrganizationInvitationResponse
func (c *ClientWithResponses) AcceptOrganizationInvitationWithResponse(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*AcceptOrganizationInvitationResponse, error) {
	rsp, err := c.AcceptOrganizationInvitation(ctx, orgName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAcceptOrganizationInvitationResponse(rsp)
}

// GetOrganizationAuthPolicyWithResponse request returning *GetOrganizationAuthPolicyResponse
func (c *ClientWithResponses) GetOrganizationAuthPolicyWithResponse(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*GetOrganizationAuthPolicyResponse, error) {
	rsp, err := c.GetOrganizationAuthPolicy(ctx, orgName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationAuthPolicyResponse(rsp)
}

// UpdateOrganizationAuthPolicyWithBodyWithResponse request with arbitrary body returning *UpdateOrganizationAuthPolicyResponse
func (c *ClientWithResponses) UpdateOrganizationAuthPolicyWithBodyWithResponse(ctx context.Context, orgName OrgNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrganizationAuthPolicyResponse, error) {
	rsp, err := c.UpdateOrganizationAuthPolicyWithBody(ctx, orgName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrganizationAuthPolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdateOrganizationAuthPolicyWithResponse(ctx context.Context, orgName OrgNameParam, body UpdateOrganizationAuthPolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrganizationAuthPolicyResponse, error) {
	rsp, err := c.UpdateOrganizationAuthPolicy(ctx, orgName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrganizationAuthPolicyResponse(rsp)
}

// DeleteOrganizationMemberWithResponse request returning *DeleteOrganizationMemberResponse
func (c *ClientWithResponses) DeleteOrganizationMemberWithResponse(ctx context.Context, orgName OrgNameParam, userAlias UserAliasParam, reqEditors ...RequestEditorFn) (*DeleteOrganizationMemberResponse, error) {
	rsp, err := c.DeleteOrganizationMember(ctx, orgName, userAlias, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrganizationMemberResponse(rsp)
}

// AddOrganizationMemberWithResponse request returning *AddOrganizationMemberResponse
func (c *ClientWithResponses) AddOrganizationMemberWithResponse(ctx context.Context, orgName OrgNameParam, userAlias UserAliasParam, reqEditors ...RequestEditorFn) (*AddOrganizationMemberResponse, error) {
	rsp, err := c.AddOrganizationMember(ctx, orgName, userAlias, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationMemberResponse(rsp)
}

// GetOrganizationMembersWithResponse request returning *GetOrganizationMembersResponse
func (c *ClientWithResponses) GetOrganizationMembersWithResponse(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*GetOrganizationMembersResponse, error) {
	rsp, err := c.GetOrganizationMembers(ctx, orgName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationMembersResponse(rsp)
}

// GetAllowedActionsWithResponse request returning *GetAllowedActionsResponse
func (c *ClientWithResponses) GetAllowedActionsWithResponse(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*GetAllowedActionsResponse, error) {
	rsp, err := c.GetAllowedActions(ctx, orgName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAllowedActionsResponse(rsp)
}

// GetArgoTemplatesDetailsWithResponse request returning *GetArgoTemplatesDetailsResponse
func (c *ClientWithResponses) GetArgoTemplatesDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetArgoTemplatesDetailsResponse, error) {
	rsp, err := c.GetArgoTemplatesDetails(ctx, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArgoTemplatesDetailsResponse(rsp)
}

// GetArgoTemplatesVersionDetailsWithResponse request returning *GetArgoTemplatesVersionDetailsResponse
func (c *ClientWithResponses) GetArgoTemplatesVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetArgoTemplatesVersionDetailsResponse, error) {
	rsp, err := c.GetArgoTemplatesVersionDetails(ctx, repoName, packageName, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArgoTemplatesVersionDetailsResponse(rsp)
}

// GetBackstagePluginsDetailsWithResponse request returning *GetBackstagePluginsDetailsResponse
func (c *ClientWithResponses) GetBackstagePluginsDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetBackstagePluginsDetailsResponse, error) {
	rsp, err := c.GetBackstagePluginsDetails(ctx, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackstagePluginsDetailsResponse(rsp)
}

// GetBackstagePluginsVersionDetailsWithResponse request returning *GetBackstagePluginsVersionDetailsResponse
func (c *ClientWithResponses) GetBackstagePluginsVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetBackstagePluginsVersionDetailsResponse, error) {
	rsp, err := c.GetBackstagePluginsVersionDetails(ctx, repoName, packageName, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackstagePluginsVersionDetailsResponse(rsp)
}

// GetContainerImageDetailsWithResponse request returning *GetContainerImageDetailsResponse
func (c *ClientWithResponses) GetContainerImageDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetContainerImageDetailsResponse, error) {
	rsp, err := c.GetContainerImageDetails(ctx, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContainerImageDetailsResponse(rsp)
}

// GetContainerImageVersionDetailsWithResponse request returning *GetContainerImageVersionDetailsResponse
func (c *ClientWithResponses) GetContainerImageVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetContainerImageVersionDetailsResponse, error) {
	rsp, err := c.GetContainerImageVersionDetails(ctx, repoName, packageName, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetContainerImageVersionDetailsResponse(rsp)
}

// GetCoreDNSPluginDetailsWithResponse request returning *GetCoreDNSPluginDetailsResponse
func (c *ClientWithResponses) GetCoreDNSPluginDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetCoreDNSPluginDetailsResponse, error) {
	rsp, err := c.GetCoreDNSPluginDetails(ctx, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCoreDNSPluginDetailsResponse(rsp)
}

// GetCoreDNSPluginVersionDetailsWithResponse request returning *GetCoreDNSPluginVersionDetailsResponse
func (c *ClientWithResponses) GetCoreDNSPluginVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetCoreDNSPluginVersionDetailsResponse, error) {
	rsp, err := c.GetCoreDNSPluginVersionDetails(ctx, repoName, packageName, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCoreDNSPluginVersionDetailsResponse(rsp)
}

// GetFalcoRulesDetailsWithResponse request returning *GetFalcoRulesDetailsResponse
func (c *ClientWithResponses) GetFalcoRulesDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetFalcoRulesDetailsResponse, error) {
	rsp, err := c.GetFalcoRulesDetails(ctx, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFalcoRulesDetailsResponse(rsp)
}

// GetFalcoRulesVersionDetailsWithResponse request returning *GetFalcoRulesVersionDetailsResponse
func (c *ClientWithResponses) GetFalcoRulesVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetFalcoRulesVersionDetailsResponse, error) {
	rsp, err := c.GetFalcoRulesVersionDetails(ctx, repoName, packageName, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFalcoRulesVersionDetailsResponse(rsp)
}

// GetGatekeeperPoliciesDetailsWithResponse request returning *GetGatekeeperPoliciesDetailsResponse
func (c *ClientWithResponses) GetGatekeeperPoliciesDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetGatekeeperPoliciesDetailsResponse, error) {
	rsp, err := c.GetGatekeeperPoliciesDetails(ctx, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGatekeeperPoliciesDetailsResponse(rsp)
}

// GetGatekeeperPoliciesVersionDetailsWithResponse request returning *GetGatekeeperPoliciesVersionDetailsResponse
func (c *ClientWithResponses) GetGatekeeperPoliciesVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetGatekeeperPoliciesVersionDetailsResponse, error) {
	rsp, err := c.GetGatekeeperPoliciesVersionDetails(ctx, repoName, packageName, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGatekeeperPoliciesVersionDetailsResponse(rsp)
}

// GetHelmPluginDetailsWithResponse request returning *GetHelmPluginDetailsResponse
func (c *ClientWithResponses) GetHelmPluginDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetHelmPluginDetailsResponse, error) {
	rsp, err := c.GetHelmPluginDetails(ctx, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHelmPluginDetailsResponse(rsp)
}

// GetHelmPluginVersionDetailsWithResponse request returning *GetHelmPluginVersionDetailsResponse
func (c *ClientWithResponses) GetHelmPluginVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetHelmPluginVersionDetailsResponse, error) {
	rsp, err := c.GetHelmPluginVersionDetails(ctx, repoName, packageName, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHelmPluginVersionDetailsResponse(rsp)
}

// GetHelmPackageDetailsWithResponse request returning *GetHelmPackageDetailsResponse
func (c *ClientWithResponses) GetHelmPackageDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetHelmPackageDetailsResponse, error) {
	rsp, err := c.GetHelmPackageDetails(ctx, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHelmPackageDetailsResponse(rsp)
}

// GetHelmPackageVersionDetailsWithResponse request returning *GetHelmPackageVersionDetailsResponse
func (c *ClientWithResponses) GetHelmPackageVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetHelmPackageVersionDetailsResponse, error) {
	rsp, err := c.GetHelmPackageVersionDetails(ctx, repoName, packageName, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHelmPackageVersionDetailsResponse(rsp)
}

// GetKedaScalerDetailsWithResponse request returning *GetKedaScalerDetailsResponse
func (c *ClientWithResponses) GetKedaScalerDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetKedaScalerDetailsResponse, error) {
	rsp, err := c.GetKedaScalerDetails(ctx, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKedaScalerDetailsResponse(rsp)
}

// GetKedaScalerVersionDetailsWithResponse request returning *GetKedaScalerVersionDetailsResponse
func (c *ClientWithResponses) GetKedaScalerVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetKedaScalerVersionDetailsResponse, error) {
	rsp, err := c.GetKedaScalerVersionDetails(ctx, repoName, packageName, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKedaScalerVersionDetailsResponse(rsp)
}

// GetKeptnIntegrationsDetailsWithResponse request returning *GetKeptnIntegrationsDetailsResponse
func (c *ClientWithResponses) GetKeptnIntegrationsDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetKeptnIntegrationsDetailsResponse, error) {
	rsp, err := c.GetKeptnIntegrationsDetails(ctx, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeptnIntegrationsDetailsResponse(rsp)
}

// GetKeptnIntegrationsVersionDetailsWithResponse request returning *GetKeptnIntegrationsVersionDetailsResponse
func (c *ClientWithResponses) GetKeptnIntegrationsVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetKeptnIntegrationsVersionDetailsResponse, error) {
	rsp, err := c.GetKeptnIntegrationsVersionDetails(ctx, repoName, packageName, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKeptnIntegrationsVersionDetailsResponse(rsp)
}

// GetKnativeClientPluginIntegrationsDetailsWithResponse request returning *GetKnativeClientPluginIntegrationsDetailsResponse
func (c *ClientWithResponses) GetKnativeClientPluginIntegrationsDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetKnativeClientPluginIntegrationsDetailsResponse, error) {
	rsp, err := c.GetKnativeClientPluginIntegrationsDetails(ctx, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKnativeClientPluginIntegrationsDetailsResponse(rsp)
}

// GetKnativeClientPluginsVersionDetailsWithResponse request returning *GetKnativeClientPluginsVersionDetailsResponse
func (c *ClientWithResponses) GetKnativeClientPluginsVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetKnativeClientPluginsVersionDetailsResponse, error) {
	rsp, err := c.GetKnativeClientPluginsVersionDetails(ctx, repoName, packageName, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKnativeClientPluginsVersionDetailsResponse(rsp)
}

// GetKubectlPluginDetailsWithResponse request returning *GetKubectlPluginDetailsResponse
func (c *ClientWithResponses) GetKubectlPluginDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetKubectlPluginDetailsResponse, error) {
	rsp, err := c.GetKubectlPluginDetails(ctx, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKubectlPluginDetailsResponse(rsp)
}

// GetKubectlPluginVersionDetailsWithResponse request returning *GetKubectlPluginVersionDetailsResponse
func (c *ClientWithResponses) GetKubectlPluginVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetKubectlPluginVersionDetailsResponse, error) {
	rsp, err := c.GetKubectlPluginVersionDetails(ctx, repoName, packageName, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKubectlPluginVersionDetailsResponse(rsp)
}

// GetKubeArmorPoliciesDetailsWithResponse request returning *GetKubeArmorPoliciesDetailsResponse
func (c *ClientWithResponses) GetKubeArmorPoliciesDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetKubeArmorPoliciesDetailsResponse, error) {
	rsp, err := c.GetKubeArmorPoliciesDetails(ctx, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKubeArmorPoliciesDetailsResponse(rsp)
}

// GetKubeArmorPoliciesVersionDetailsWithResponse request returning *GetKubeArmorPoliciesVersionDetailsResponse
func (c *ClientWithResponses) GetKubeArmorPoliciesVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetKubeArmorPoliciesVersionDetailsResponse, error) {
	rsp, err := c.GetKubeArmorPoliciesVersionDetails(ctx, repoName, packageName, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKubeArmorPoliciesVersionDetailsResponse(rsp)
}

// GetKubewardenPoliciesDetailsWithResponse request returning *GetKubewardenPoliciesDetailsResponse
func (c *ClientWithResponses) GetKubewardenPoliciesDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetKubewardenPoliciesDetailsResponse, error) {
	rsp, err := c.GetKubewardenPoliciesDetails(ctx, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKubewardenPoliciesDetailsResponse(rsp)
}

// GetKubewardenPoliciesVersionDetailsWithResponse request returning *GetKubewardenPoliciesVersionDetailsResponse
func (c *ClientWithResponses) GetKubewardenPoliciesVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetKubewardenPoliciesVersionDetailsResponse, error) {
	rsp, err := c.GetKubewardenPoliciesVersionDetails(ctx, repoName, packageName, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKubewardenPoliciesVersionDetailsResponse(rsp)
}

// GetKyvernoPoliciesDetailsWithResponse request returning *GetKyvernoPoliciesDetailsResponse
func (c *ClientWithResponses) GetKyvernoPoliciesDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetKyvernoPoliciesDetailsResponse, error) {
	rsp, err := c.GetKyvernoPoliciesDetails(ctx, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKyvernoPoliciesDetailsResponse(rsp)
}

// GetKyvernoPoliciesVersionDetailsWithResponse request returning *GetKyvernoPoliciesVersionDetailsResponse
func (c *ClientWithResponses) GetKyvernoPoliciesVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetKyvernoPoliciesVersionDetailsResponse, error) {
	rsp, err := c.GetKyvernoPoliciesVersionDetails(ctx, repoName, packageName, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetKyvernoPoliciesVersionDetailsResponse(rsp)
}

// GetOLMOperatorDetailsWithResponse request returning *GetOLMOperatorDetailsResponse
func (c *ClientWithResponses) GetOLMOperatorDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetOLMOperatorDetailsResponse, error) {
	rsp, err := c.GetOLMOperatorDetails(ctx, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOLMOperatorDetailsResponse(rsp)
}

// GetOLMOperatorVersionDetailsWithResponse request returning *GetOLMOperatorVersionDetailsResponse
func (c *ClientWithResponses) GetOLMOperatorVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetOLMOperatorVersionDetailsResponse, error) {
	rsp, err := c.GetOLMOperatorVersionDetails(ctx, repoName, packageName, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOLMOperatorVersionDetailsResponse(rsp)
}

// GetOPAPoliciesDetailsWithResponse request returning *GetOPAPoliciesDetailsResponse
func (c *ClientWithResponses) GetOPAPoliciesDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetOPAPoliciesDetailsResponse, error) {
	rsp, err := c.GetOPAPoliciesDetails(ctx, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOPAPoliciesDetailsResponse(rsp)
}

// GetOPAPoliciesVersionDetailsWithResponse request returning *GetOPAPoliciesVersionDetailsResponse
func (c *ClientWithResponses) GetOPAPoliciesVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetOPAPoliciesVersionDetailsResponse, error) {
	rsp, err := c.GetOPAPoliciesVersionDetails(ctx, repoName, packageName, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOPAPoliciesVersionDetailsResponse(rsp)
}

// GetRandomPackagesWithResponse request returning *GetRandomPackagesResponse
func (c *ClientWithResponses) GetRandomPackagesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetRandomPackagesResponse, error) {
	rsp, err := c.GetRandomPackages(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRandomPackagesResponse(rsp)
}

// SearchPackagesWithResponse request returning *SearchPackagesResponse
func (c *ClientWithResponses) SearchPackagesWithResponse(ctx context.Context, params *SearchPackagesParams, reqEditors ...RequestEditorFn) (*SearchPackagesResponse, error) {
	rsp, err := c.SearchPackages(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchPackagesResponse(rsp)
}

// GetStarredPackagesByUserWithResponse request returning *GetStarredPackagesByUserResponse
func (c *ClientWithResponses) GetStarredPackagesByUserWithResponse(ctx context.Context, params *GetStarredPackagesByUserParams, reqEditors ...RequestEditorFn) (*GetStarredPackagesByUserResponse, error) {
	rsp, err := c.GetStarredPackagesByUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStarredPackagesByUserResponse(rsp)
}

// GetPackageStatsWithResponse request returning *GetPackageStatsResponse
func (c *ClientWithResponses) GetPackageStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPackageStatsResponse, error) {
	rsp, err := c.GetPackageStats(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPackageStatsResponse(rsp)
}

// GetTinkerbellActionsDetailsWithResponse request returning *GetTinkerbellActionsDetailsResponse
func (c *ClientWithResponses) GetTinkerbellActionsDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetTinkerbellActionsDetailsResponse, error) {
	rsp, err := c.GetTinkerbellActionsDetails(ctx, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTinkerbellActionsDetailsResponse(rsp)
}

// GetTinkerbellActionsVersionDetailsWithResponse request returning *GetTinkerbellActionsVersionDetailsResponse
func (c *ClientWithResponses) GetTinkerbellActionsVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetTinkerbellActionsVersionDetailsResponse, error) {
	rsp, err := c.GetTinkerbellActionsVersionDetails(ctx, repoName, packageName, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTinkerbellActionsVersionDetailsResponse(rsp)
}

// GetTektonPipelineDetailsWithResponse request returning *GetTektonPipelineDetailsResponse
func (c *ClientWithResponses) GetTektonPipelineDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetTektonPipelineDetailsResponse, error) {
	rsp, err := c.GetTektonPipelineDetails(ctx, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTektonPipelineDetailsResponse(rsp)
}

// GetTektonPipelineVersionDetailsWithResponse request returning *GetTektonPipelineVersionDetailsResponse
func (c *ClientWithResponses) GetTektonPipelineVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetTektonPipelineVersionDetailsResponse, error) {
	rsp, err := c.GetTektonPipelineVersionDetails(ctx, repoName, packageName, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTektonPipelineVersionDetailsResponse(rsp)
}

// GetTektonTaskDetailsWithResponse request returning *GetTektonTaskDetailsResponse
func (c *ClientWithResponses) GetTektonTaskDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetTektonTaskDetailsResponse, error) {
	rsp, err := c.GetTektonTaskDetails(ctx, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTektonTaskDetailsResponse(rsp)
}

// GetTektonTaskVersionDetailsWithResponse request returning *GetTektonTaskVersionDetailsResponse
func (c *ClientWithResponses) GetTektonTaskVersionDetailsWithResponse(ctx context.Context, repoName RepoNameParam, packageName PackageNameParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetTektonTaskVersionDetailsResponse, error) {
	rsp, err := c.GetTektonTaskVersionDetails(ctx, repoName, packageName, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTektonTaskVersionDetailsResponse(rsp)
}

// GetPackageChangelogWithResponse request returning *GetPackageChangelogResponse
func (c *ClientWithResponses) GetPackageChangelogWithResponse(ctx context.Context, packageID PackageIDParam, reqEditors ...RequestEditorFn) (*GetPackageChangelogResponse, error) {
	rsp, err := c.GetPackageChangelog(ctx, packageID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPackageChangelogResponse(rsp)
}

// GetPackageStarsWithResponse request returning *GetPackageStarsResponse
func (c *ClientWithResponses) GetPackageStarsWithResponse(ctx context.Context, packageID PackageIDParam, reqEditors ...RequestEditorFn) (*GetPackageStarsResponse, error) {
	rsp, err := c.GetPackageStars(ctx, packageID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPackageStarsResponse(rsp)
}

// TogglePackageStarWithResponse request returning *TogglePackageStarResponse
func (c *ClientWithResponses) TogglePackageStarWithResponse(ctx context.Context, packageID PackageIDParam, reqEditors ...RequestEditorFn) (*TogglePackageStarResponse, error) {
	rsp, err := c.TogglePackageStar(ctx, packageID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTogglePackageStarResponse(rsp)
}

// GetPackageViewsWithResponse request returning *GetPackageViewsResponse
func (c *ClientWithResponses) GetPackageViewsWithResponse(ctx context.Context, packageID PackageIDParam, reqEditors ...RequestEditorFn) (*GetPackageViewsResponse, error) {
	rsp, err := c.GetPackageViews(ctx, packageID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPackageViewsResponse(rsp)
}

// GetPackageSecurityReportWithResponse request returning *GetPackageSecurityReportResponse
func (c *ClientWithResponses) GetPackageSecurityReportWithResponse(ctx context.Context, packageID PackageIDParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetPackageSecurityReportResponse, error) {
	rsp, err := c.GetPackageSecurityReport(ctx, packageID, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPackageSecurityReportResponse(rsp)
}

// GetHelmChartTemplatesWithResponse request returning *GetHelmChartTemplatesResponse
func (c *ClientWithResponses) GetHelmChartTemplatesWithResponse(ctx context.Context, packageID PackageIDParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetHelmChartTemplatesResponse, error) {
	rsp, err := c.GetHelmChartTemplates(ctx, packageID, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetHelmChartTemplatesResponse(rsp)
}

// GetChartValuesWithResponse request returning *GetChartValuesResponse
func (c *ClientWithResponses) GetChartValuesWithResponse(ctx context.Context, packageID PackageIDParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetChartValuesResponse, error) {
	rsp, err := c.GetChartValues(ctx, packageID, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChartValuesResponse(rsp)
}

// GetPackageValuesSchemaWithResponse request returning *GetPackageValuesSchemaResponse
func (c *ClientWithResponses) GetPackageValuesSchemaWithResponse(ctx context.Context, packageID PackageIDParam, version VersionParam, reqEditors ...RequestEditorFn) (*GetPackageValuesSchemaResponse, error) {
	rsp, err := c.GetPackageValuesSchema(ctx, packageID, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPackageValuesSchemaResponse(rsp)
}

// GenerateChangelogMDWithResponse request returning *GenerateChangelogMDResponse
func (c *ClientWithResponses) GenerateChangelogMDWithResponse(ctx context.Context, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GenerateChangelogMDResponse, error) {
	rsp, err := c.GenerateChangelogMD(ctx, repoKindParam, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGenerateChangelogMDResponse(rsp)
}

// GetProductionUsageWithResponse request returning *GetProductionUsageResponse
func (c *ClientWithResponses) GetProductionUsageWithResponse(ctx context.Context, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetProductionUsageResponse, error) {
	rsp, err := c.GetProductionUsage(ctx, repoKindParam, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetProductionUsageResponse(rsp)
}

// DeleteProductionUsageWithResponse request returning *DeleteProductionUsageResponse
func (c *ClientWithResponses) DeleteProductionUsageWithResponse(ctx context.Context, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*DeleteProductionUsageResponse, error) {
	rsp, err := c.DeleteProductionUsage(ctx, repoKindParam, repoName, packageName, orgName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteProductionUsageResponse(rsp)
}

// AddProductionUsageWithResponse request returning *AddProductionUsageResponse
func (c *ClientWithResponses) AddProductionUsageWithResponse(ctx context.Context, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*AddProductionUsageResponse, error) {
	rsp, err := c.AddProductionUsage(ctx, repoKindParam, repoName, packageName, orgName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddProductionUsageResponse(rsp)
}

// GetPackageSummaryWithResponse request returning *GetPackageSummaryResponse
func (c *ClientWithResponses) GetPackageSummaryWithResponse(ctx context.Context, repoKindParam RepoKindParam, repoName RepoNameParam, packageName PackageNameParam, reqEditors ...RequestEditorFn) (*GetPackageSummaryResponse, error) {
	rsp, err := c.GetPackageSummary(ctx, repoKindParam, repoName, packageName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPackageSummaryResponse(rsp)
}

// AddOrganizationRepositoryWithBodyWithResponse request with arbitrary body returning *AddOrganizationRepositoryResponse
func (c *ClientWithResponses) AddOrganizationRepositoryWithBodyWithResponse(ctx context.Context, orgName OrgNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationRepositoryResponse, error) {
	rsp, err := c.AddOrganizationRepositoryWithBody(ctx, orgName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationRepositoryResponse(rsp)
}

func (c *ClientWithResponses) AddOrganizationRepositoryWithResponse(ctx context.Context, orgName OrgNameParam, body AddOrganizationRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationRepositoryResponse, error) {
	rsp, err := c.AddOrganizationRepository(ctx, orgName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationRepositoryResponse(rsp)
}

// DeleteOrganizationRepositoryWithResponse request returning *DeleteOrganizationRepositoryResponse
func (c *ClientWithResponses) DeleteOrganizationRepositoryWithResponse(ctx context.Context, orgName OrgNameParam, repoName RepoNameParam, reqEditors ...RequestEditorFn) (*DeleteOrganizationRepositoryResponse, error) {
	rsp, err := c.DeleteOrganizationRepository(ctx, orgName, repoName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrganizationRepositoryResponse(rsp)
}

// UpdateOrganizationRepositoryWithBodyWithResponse request with arbitrary body returning *UpdateOrganizationRepositoryResponse
func (c *ClientWithResponses) UpdateOrganizationRepositoryWithBodyWithResponse(ctx context.Context, orgName OrgNameParam, repoName RepoNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrganizationRepositoryResponse, error) {
	rsp, err := c.UpdateOrganizationRepositoryWithBody(ctx, orgName, repoName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrganizationRepositoryResponse(rsp)
}

func (c *ClientWithResponses) UpdateOrganizationRepositoryWithResponse(ctx context.Context, orgName OrgNameParam, repoName RepoNameParam, body UpdateOrganizationRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrganizationRepositoryResponse, error) {
	rsp, err := c.UpdateOrganizationRepository(ctx, orgName, repoName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrganizationRepositoryResponse(rsp)
}

// ClaimRepositoryOwnershipFromOrganizationWithResponse request returning *ClaimRepositoryOwnershipFromOrganizationResponse
func (c *ClientWithResponses) ClaimRepositoryOwnershipFromOrganizationWithResponse(ctx context.Context, orgName OrgNameParam, repoName RepoNameParam, params *ClaimRepositoryOwnershipFromOrganizationParams, reqEditors ...RequestEditorFn) (*ClaimRepositoryOwnershipFromOrganizationResponse, error) {
	rsp, err := c.ClaimRepositoryOwnershipFromOrganization(ctx, orgName, repoName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClaimRepositoryOwnershipFromOrganizationResponse(rsp)
}

// TransferRepositoryOwnershipWithResponse request returning *TransferRepositoryOwnershipResponse
func (c *ClientWithResponses) TransferRepositoryOwnershipWithResponse(ctx context.Context, orgName OrgNameParam, repoName RepoNameParam, params *TransferRepositoryOwnershipParams, reqEditors ...RequestEditorFn) (*TransferRepositoryOwnershipResponse, error) {
	rsp, err := c.TransferRepositoryOwnership(ctx, orgName, repoName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferRepositoryOwnershipResponse(rsp)
}

// SearchRepositoriesWithResponse request returning *SearchRepositoriesResponse
func (c *ClientWithResponses) SearchRepositoriesWithResponse(ctx context.Context, params *SearchRepositoriesParams, reqEditors ...RequestEditorFn) (*SearchRepositoriesResponse, error) {
	rsp, err := c.SearchRepositories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchRepositoriesResponse(rsp)
}

// AddUserRepositoryWithBodyWithResponse request with arbitrary body returning *AddUserRepositoryResponse
func (c *ClientWithResponses) AddUserRepositoryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserRepositoryResponse, error) {
	rsp, err := c.AddUserRepositoryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserRepositoryResponse(rsp)
}

func (c *ClientWithResponses) AddUserRepositoryWithResponse(ctx context.Context, body AddUserRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserRepositoryResponse, error) {
	rsp, err := c.AddUserRepository(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserRepositoryResponse(rsp)
}

// DeleteUserRepositoryWithResponse request returning *DeleteUserRepositoryResponse
func (c *ClientWithResponses) DeleteUserRepositoryWithResponse(ctx context.Context, repoName RepoNameParam, reqEditors ...RequestEditorFn) (*DeleteUserRepositoryResponse, error) {
	rsp, err := c.DeleteUserRepository(ctx, repoName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserRepositoryResponse(rsp)
}

// UpdateUserRepositoryWithBodyWithResponse request with arbitrary body returning *UpdateUserRepositoryResponse
func (c *ClientWithResponses) UpdateUserRepositoryWithBodyWithResponse(ctx context.Context, repoName RepoNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserRepositoryResponse, error) {
	rsp, err := c.UpdateUserRepositoryWithBody(ctx, repoName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserRepositoryResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserRepositoryWithResponse(ctx context.Context, repoName RepoNameParam, body UpdateUserRepositoryJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserRepositoryResponse, error) {
	rsp, err := c.UpdateUserRepository(ctx, repoName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserRepositoryResponse(rsp)
}

// ClaimRepositoryOwnershipWithResponse request returning *ClaimRepositoryOwnershipResponse
func (c *ClientWithResponses) ClaimRepositoryOwnershipWithResponse(ctx context.Context, repoName RepoNameParam, params *ClaimRepositoryOwnershipParams, reqEditors ...RequestEditorFn) (*ClaimRepositoryOwnershipResponse, error) {
	rsp, err := c.ClaimRepositoryOwnership(ctx, repoName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseClaimRepositoryOwnershipResponse(rsp)
}

// TransferRepositoryOwnershipToOrganizationWithResponse request returning *TransferRepositoryOwnershipToOrganizationResponse
func (c *ClientWithResponses) TransferRepositoryOwnershipToOrganizationWithResponse(ctx context.Context, repoName RepoNameParam, params *TransferRepositoryOwnershipToOrganizationParams, reqEditors ...RequestEditorFn) (*TransferRepositoryOwnershipToOrganizationResponse, error) {
	rsp, err := c.TransferRepositoryOwnershipToOrganization(ctx, repoName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTransferRepositoryOwnershipToOrganizationResponse(rsp)
}

// GetArtifactHubStatsWithResponse request returning *GetArtifactHubStatsResponse
func (c *ClientWithResponses) GetArtifactHubStatsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetArtifactHubStatsResponse, error) {
	rsp, err := c.GetArtifactHubStats(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetArtifactHubStatsResponse(rsp)
}

// DeletePackageSubscriptionWithResponse request returning *DeletePackageSubscriptionResponse
func (c *ClientWithResponses) DeletePackageSubscriptionWithResponse(ctx context.Context, params *DeletePackageSubscriptionParams, reqEditors ...RequestEditorFn) (*DeletePackageSubscriptionResponse, error) {
	rsp, err := c.DeletePackageSubscription(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePackageSubscriptionResponse(rsp)
}

// GetUserSubscriptionsWithResponse request returning *GetUserSubscriptionsResponse
func (c *ClientWithResponses) GetUserSubscriptionsWithResponse(ctx context.Context, params *GetUserSubscriptionsParams, reqEditors ...RequestEditorFn) (*GetUserSubscriptionsResponse, error) {
	rsp, err := c.GetUserSubscriptions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserSubscriptionsResponse(rsp)
}

// AddPackageSubscriptionWithBodyWithResponse request with arbitrary body returning *AddPackageSubscriptionResponse
func (c *ClientWithResponses) AddPackageSubscriptionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddPackageSubscriptionResponse, error) {
	rsp, err := c.AddPackageSubscriptionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPackageSubscriptionResponse(rsp)
}

func (c *ClientWithResponses) AddPackageSubscriptionWithResponse(ctx context.Context, body AddPackageSubscriptionJSONRequestBody, reqEditors ...RequestEditorFn) (*AddPackageSubscriptionResponse, error) {
	rsp, err := c.AddPackageSubscription(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddPackageSubscriptionResponse(rsp)
}

// GetUserOptOutEntriesWithResponse request returning *GetUserOptOutEntriesResponse
func (c *ClientWithResponses) GetUserOptOutEntriesWithResponse(ctx context.Context, params *GetUserOptOutEntriesParams, reqEditors ...RequestEditorFn) (*GetUserOptOutEntriesResponse, error) {
	rsp, err := c.GetUserOptOutEntries(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserOptOutEntriesResponse(rsp)
}

// AddOptOutEntryWithBodyWithResponse request with arbitrary body returning *AddOptOutEntryResponse
func (c *ClientWithResponses) AddOptOutEntryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOptOutEntryResponse, error) {
	rsp, err := c.AddOptOutEntryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOptOutEntryResponse(rsp)
}

func (c *ClientWithResponses) AddOptOutEntryWithResponse(ctx context.Context, body AddOptOutEntryJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOptOutEntryResponse, error) {
	rsp, err := c.AddOptOutEntry(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOptOutEntryResponse(rsp)
}

// DeleteOptOutEntryWithResponse request returning *DeleteOptOutEntryResponse
func (c *ClientWithResponses) DeleteOptOutEntryWithResponse(ctx context.Context, optOutID OptOutIDParam, reqEditors ...RequestEditorFn) (*DeleteOptOutEntryResponse, error) {
	rsp, err := c.DeleteOptOutEntry(ctx, optOutID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOptOutEntryResponse(rsp)
}

// GetPackageUserSubscriptionsWithResponse request returning *GetPackageUserSubscriptionsResponse
func (c *ClientWithResponses) GetPackageUserSubscriptionsWithResponse(ctx context.Context, packageID PackageIDParam, reqEditors ...RequestEditorFn) (*GetPackageUserSubscriptionsResponse, error) {
	rsp, err := c.GetPackageUserSubscriptions(ctx, packageID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPackageUserSubscriptionsResponse(rsp)
}

// RegisterUserWithBodyWithResponse request with arbitrary body returning *RegisterUserResponse
func (c *ClientWithResponses) RegisterUserWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RegisterUserResponse, error) {
	rsp, err := c.RegisterUserWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterUserResponse(rsp)
}

func (c *ClientWithResponses) RegisterUserWithResponse(ctx context.Context, body RegisterUserJSONRequestBody, reqEditors ...RequestEditorFn) (*RegisterUserResponse, error) {
	rsp, err := c.RegisterUser(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRegisterUserResponse(rsp)
}

// UpdateUserPasswordWithBodyWithResponse request with arbitrary body returning *UpdateUserPasswordResponse
func (c *ClientWithResponses) UpdateUserPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserPasswordResponse, error) {
	rsp, err := c.UpdateUserPasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserPasswordResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserPasswordWithResponse(ctx context.Context, body UpdateUserPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserPasswordResponse, error) {
	rsp, err := c.UpdateUserPassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserPasswordResponse(rsp)
}

// ResetPasswordCodeWithBodyWithResponse request with arbitrary body returning *ResetPasswordCodeResponse
func (c *ClientWithResponses) ResetPasswordCodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordCodeResponse, error) {
	rsp, err := c.ResetPasswordCodeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordCodeResponse(rsp)
}

func (c *ClientWithResponses) ResetPasswordCodeWithResponse(ctx context.Context, body ResetPasswordCodeJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordCodeResponse, error) {
	rsp, err := c.ResetPasswordCode(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordCodeResponse(rsp)
}

// GetUserProfileWithResponse request returning *GetUserProfileResponse
func (c *ClientWithResponses) GetUserProfileWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserProfileResponse, error) {
	rsp, err := c.GetUserProfile(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserProfileResponse(rsp)
}

// UpdateUserProfileWithBodyWithResponse request with arbitrary body returning *UpdateUserProfileResponse
func (c *ClientWithResponses) UpdateUserProfileWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserProfileResponse, error) {
	rsp, err := c.UpdateUserProfileWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserProfileResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserProfileWithResponse(ctx context.Context, body UpdateUserProfileJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserProfileResponse, error) {
	rsp, err := c.UpdateUserProfile(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserProfileResponse(rsp)
}

// ResetPasswordWithBodyWithResponse request with arbitrary body returning *ResetPasswordResponse
func (c *ClientWithResponses) ResetPasswordWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPasswordWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

func (c *ClientWithResponses) ResetPasswordWithResponse(ctx context.Context, body ResetPasswordJSONRequestBody, reqEditors ...RequestEditorFn) (*ResetPasswordResponse, error) {
	rsp, err := c.ResetPassword(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResetPasswordResponse(rsp)
}

// VerifyEmailWithBodyWithResponse request with arbitrary body returning *VerifyEmailResponse
func (c *ClientWithResponses) VerifyEmailWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VerifyEmailResponse, error) {
	rsp, err := c.VerifyEmailWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyEmailResponse(rsp)
}

func (c *ClientWithResponses) VerifyEmailWithResponse(ctx context.Context, body VerifyEmailJSONRequestBody, reqEditors ...RequestEditorFn) (*VerifyEmailResponse, error) {
	rsp, err := c.VerifyEmail(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyEmailResponse(rsp)
}

// VerifyPasswordCodeWithBodyWithResponse request with arbitrary body returning *VerifyPasswordCodeResponse
func (c *ClientWithResponses) VerifyPasswordCodeWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*VerifyPasswordCodeResponse, error) {
	rsp, err := c.VerifyPasswordCodeWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyPasswordCodeResponse(rsp)
}

func (c *ClientWithResponses) VerifyPasswordCodeWithResponse(ctx context.Context, body VerifyPasswordCodeJSONRequestBody, reqEditors ...RequestEditorFn) (*VerifyPasswordCodeResponse, error) {
	rsp, err := c.VerifyPasswordCode(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseVerifyPasswordCodeResponse(rsp)
}

// GetOrganizationWebhooksWithResponse request returning *GetOrganizationWebhooksResponse
func (c *ClientWithResponses) GetOrganizationWebhooksWithResponse(ctx context.Context, orgName OrgNameParam, reqEditors ...RequestEditorFn) (*GetOrganizationWebhooksResponse, error) {
	rsp, err := c.GetOrganizationWebhooks(ctx, orgName, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationWebhooksResponse(rsp)
}

// AddOrganizationWebhookWithBodyWithResponse request with arbitrary body returning *AddOrganizationWebhookResponse
func (c *ClientWithResponses) AddOrganizationWebhookWithBodyWithResponse(ctx context.Context, orgName OrgNameParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddOrganizationWebhookResponse, error) {
	rsp, err := c.AddOrganizationWebhookWithBody(ctx, orgName, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationWebhookResponse(rsp)
}

func (c *ClientWithResponses) AddOrganizationWebhookWithResponse(ctx context.Context, orgName OrgNameParam, body AddOrganizationWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*AddOrganizationWebhookResponse, error) {
	rsp, err := c.AddOrganizationWebhook(ctx, orgName, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddOrganizationWebhookResponse(rsp)
}

// DeleteOrganizationWebhookWithResponse request returning *DeleteOrganizationWebhookResponse
func (c *ClientWithResponses) DeleteOrganizationWebhookWithResponse(ctx context.Context, orgName OrgNameParam, webhookID WebhookIDParam, reqEditors ...RequestEditorFn) (*DeleteOrganizationWebhookResponse, error) {
	rsp, err := c.DeleteOrganizationWebhook(ctx, orgName, webhookID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteOrganizationWebhookResponse(rsp)
}

// GetOrganizationWebhookDetailsWithResponse request returning *GetOrganizationWebhookDetailsResponse
func (c *ClientWithResponses) GetOrganizationWebhookDetailsWithResponse(ctx context.Context, orgName OrgNameParam, webhookID WebhookIDParam, reqEditors ...RequestEditorFn) (*GetOrganizationWebhookDetailsResponse, error) {
	rsp, err := c.GetOrganizationWebhookDetails(ctx, orgName, webhookID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetOrganizationWebhookDetailsResponse(rsp)
}

// UpdateOrganizationWebhookWithBodyWithResponse request with arbitrary body returning *UpdateOrganizationWebhookResponse
func (c *ClientWithResponses) UpdateOrganizationWebhookWithBodyWithResponse(ctx context.Context, orgName OrgNameParam, webhookID WebhookIDParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateOrganizationWebhookResponse, error) {
	rsp, err := c.UpdateOrganizationWebhookWithBody(ctx, orgName, webhookID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrganizationWebhookResponse(rsp)
}

func (c *ClientWithResponses) UpdateOrganizationWebhookWithResponse(ctx context.Context, orgName OrgNameParam, webhookID WebhookIDParam, body UpdateOrganizationWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateOrganizationWebhookResponse, error) {
	rsp, err := c.UpdateOrganizationWebhook(ctx, orgName, webhookID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateOrganizationWebhookResponse(rsp)
}

// TriggerWebhookTestWithBodyWithResponse request with arbitrary body returning *TriggerWebhookTestResponse
func (c *ClientWithResponses) TriggerWebhookTestWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TriggerWebhookTestResponse, error) {
	rsp, err := c.TriggerWebhookTestWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerWebhookTestResponse(rsp)
}

func (c *ClientWithResponses) TriggerWebhookTestWithResponse(ctx context.Context, body TriggerWebhookTestJSONRequestBody, reqEditors ...RequestEditorFn) (*TriggerWebhookTestResponse, error) {
	rsp, err := c.TriggerWebhookTest(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTriggerWebhookTestResponse(rsp)
}

// GetUserWebhooksWithResponse request returning *GetUserWebhooksResponse
func (c *ClientWithResponses) GetUserWebhooksWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserWebhooksResponse, error) {
	rsp, err := c.GetUserWebhooks(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserWebhooksResponse(rsp)
}

// AddUserWebhookWithBodyWithResponse request with arbitrary body returning *AddUserWebhookResponse
func (c *ClientWithResponses) AddUserWebhookWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddUserWebhookResponse, error) {
	rsp, err := c.AddUserWebhookWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserWebhookResponse(rsp)
}

func (c *ClientWithResponses) AddUserWebhookWithResponse(ctx context.Context, body AddUserWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*AddUserWebhookResponse, error) {
	rsp, err := c.AddUserWebhook(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddUserWebhookResponse(rsp)
}

// DeleteUserWebhookWithResponse request returning *DeleteUserWebhookResponse
func (c *ClientWithResponses) DeleteUserWebhookWithResponse(ctx context.Context, webhookID WebhookIDParam, reqEditors ...RequestEditorFn) (*DeleteUserWebhookResponse, error) {
	rsp, err := c.DeleteUserWebhook(ctx, webhookID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserWebhookResponse(rsp)
}

// GetUserWebhookDetailWithResponse request returning *GetUserWebhookDetailResponse
func (c *ClientWithResponses) GetUserWebhookDetailWithResponse(ctx context.Context, webhookID WebhookIDParam, reqEditors ...RequestEditorFn) (*GetUserWebhookDetailResponse, error) {
	rsp, err := c.GetUserWebhookDetail(ctx, webhookID, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserWebhookDetailResponse(rsp)
}

// UpdateUserWebhookWithBodyWithResponse request with arbitrary body returning *UpdateUserWebhookResponse
func (c *ClientWithResponses) UpdateUserWebhookWithBodyWithResponse(ctx context.Context, webhookID WebhookIDParam, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateUserWebhookResponse, error) {
	rsp, err := c.UpdateUserWebhookWithBody(ctx, webhookID, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserWebhookResponse(rsp)
}

func (c *ClientWithResponses) UpdateUserWebhookWithResponse(ctx context.Context, webhookID WebhookIDParam, body UpdateUserWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateUserWebhookResponse, error) {
	rsp, err := c.UpdateUserWebhook(ctx, webhookID, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateUserWebhookResponse(rsp)
}

// ParseCheckAvailabilityResponse parses an HTTP response from a CheckAvailabilityWithResponse call
func ParseCheckAvailabilityResponse(rsp *http.Response) (*CheckAvailabilityResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckAvailabilityResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetHarborReplicationDumpResponse parses an HTTP response from a GetHarborReplicationDumpWithResponse call
func ParseGetHarborReplicationDumpResponse(rsp *http.Response) (*GetHarborReplicationDumpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHarborReplicationDumpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetHelmExporterDumpResponse parses an HTTP response from a GetHelmExporterDumpWithResponse call
func ParseGetHelmExporterDumpResponse(rsp *http.Response) (*GetHelmExporterDumpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHelmExporterDumpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetNovaDumpResponse parses an HTTP response from a GetNovaDumpWithResponse call
func ParseGetNovaDumpResponse(rsp *http.Response) (*GetNovaDumpResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNovaDumpResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddOrganizationResponse parses an HTTP response from a AddOrganizationWithResponse call
func ParseAddOrganizationResponse(rsp *http.Response) (*AddOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserOrganizationsResponse parses an HTTP response from a GetUserOrganizationsWithResponse call
func ParseGetUserOrganizationsResponse(rsp *http.Response) (*GetUserOrganizationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserOrganizationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Organization
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteOrganizationResponse parses an HTTP response from a DeleteOrganizationWithResponse call
func ParseDeleteOrganizationResponse(rsp *http.Response) (*DeleteOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrganizationProfileResponse parses an HTTP response from a GetOrganizationProfileWithResponse call
func ParseGetOrganizationProfileResponse(rsp *http.Response) (*GetOrganizationProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OrganizationSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateOrganizationProfileResponse parses an HTTP response from a UpdateOrganizationProfileWithResponse call
func ParseUpdateOrganizationProfileResponse(rsp *http.Response) (*UpdateOrganizationProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOrganizationProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAcceptOrganizationInvitationResponse parses an HTTP response from a AcceptOrganizationInvitationWithResponse call
func ParseAcceptOrganizationInvitationResponse(rsp *http.Response) (*AcceptOrganizationInvitationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AcceptOrganizationInvitationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrganizationAuthPolicyResponse parses an HTTP response from a GetOrganizationAuthPolicyWithResponse call
func ParseGetOrganizationAuthPolicyResponse(rsp *http.Response) (*GetOrganizationAuthPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationAuthPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthorizationPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateOrganizationAuthPolicyResponse parses an HTTP response from a UpdateOrganizationAuthPolicyWithResponse call
func ParseUpdateOrganizationAuthPolicyResponse(rsp *http.Response) (*UpdateOrganizationAuthPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOrganizationAuthPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteOrganizationMemberResponse parses an HTTP response from a DeleteOrganizationMemberWithResponse call
func ParseDeleteOrganizationMemberResponse(rsp *http.Response) (*DeleteOrganizationMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrganizationMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddOrganizationMemberResponse parses an HTTP response from a AddOrganizationMemberWithResponse call
func ParseAddOrganizationMemberResponse(rsp *http.Response) (*AddOrganizationMemberResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOrganizationMemberResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrganizationMembersResponse parses an HTTP response from a GetOrganizationMembersWithResponse call
func ParseGetOrganizationMembersResponse(rsp *http.Response) (*GetOrganizationMembersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationMembersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Member
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetAllowedActionsResponse parses an HTTP response from a GetAllowedActionsWithResponse call
func ParseGetAllowedActionsResponse(rsp *http.Response) (*GetAllowedActionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAllowedActionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []AuthorizerAction
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetArgoTemplatesDetailsResponse parses an HTTP response from a GetArgoTemplatesDetailsWithResponse call
func ParseGetArgoTemplatesDetailsResponse(rsp *http.Response) (*GetArgoTemplatesDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArgoTemplatesDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArgoTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetArgoTemplatesVersionDetailsResponse parses an HTTP response from a GetArgoTemplatesVersionDetailsWithResponse call
func ParseGetArgoTemplatesVersionDetailsResponse(rsp *http.Response) (*GetArgoTemplatesVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArgoTemplatesVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ArgoTemplate
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBackstagePluginsDetailsResponse parses an HTTP response from a GetBackstagePluginsDetailsWithResponse call
func ParseGetBackstagePluginsDetailsResponse(rsp *http.Response) (*GetBackstagePluginsDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackstagePluginsDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackstagePlugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetBackstagePluginsVersionDetailsResponse parses an HTTP response from a GetBackstagePluginsVersionDetailsWithResponse call
func ParseGetBackstagePluginsVersionDetailsResponse(rsp *http.Response) (*GetBackstagePluginsVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackstagePluginsVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest BackstagePlugin
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetContainerImageDetailsResponse parses an HTTP response from a GetContainerImageDetailsWithResponse call
func ParseGetContainerImageDetailsResponse(rsp *http.Response) (*GetContainerImageDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContainerImageDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContainerImage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetContainerImageVersionDetailsResponse parses an HTTP response from a GetContainerImageVersionDetailsWithResponse call
func ParseGetContainerImageVersionDetailsResponse(rsp *http.Response) (*GetContainerImageVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetContainerImageVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ContainerImage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCoreDNSPluginDetailsResponse parses an HTTP response from a GetCoreDNSPluginDetailsWithResponse call
func ParseGetCoreDNSPluginDetailsResponse(rsp *http.Response) (*GetCoreDNSPluginDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCoreDNSPluginDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoreDNSPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCoreDNSPluginVersionDetailsResponse parses an HTTP response from a GetCoreDNSPluginVersionDetailsWithResponse call
func ParseGetCoreDNSPluginVersionDetailsResponse(rsp *http.Response) (*GetCoreDNSPluginVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCoreDNSPluginVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoreDNSPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetFalcoRulesDetailsResponse parses an HTTP response from a GetFalcoRulesDetailsWithResponse call
func ParseGetFalcoRulesDetailsResponse(rsp *http.Response) (*GetFalcoRulesDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFalcoRulesDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FalcoPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetFalcoRulesVersionDetailsResponse parses an HTTP response from a GetFalcoRulesVersionDetailsWithResponse call
func ParseGetFalcoRulesVersionDetailsResponse(rsp *http.Response) (*GetFalcoRulesVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFalcoRulesVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FalcoPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGatekeeperPoliciesDetailsResponse parses an HTTP response from a GetGatekeeperPoliciesDetailsWithResponse call
func ParseGetGatekeeperPoliciesDetailsResponse(rsp *http.Response) (*GetGatekeeperPoliciesDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGatekeeperPoliciesDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GatekeeperPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetGatekeeperPoliciesVersionDetailsResponse parses an HTTP response from a GetGatekeeperPoliciesVersionDetailsWithResponse call
func ParseGetGatekeeperPoliciesVersionDetailsResponse(rsp *http.Response) (*GetGatekeeperPoliciesVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGatekeeperPoliciesVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GatekeeperPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetHelmPluginDetailsResponse parses an HTTP response from a GetHelmPluginDetailsWithResponse call
func ParseGetHelmPluginDetailsResponse(rsp *http.Response) (*GetHelmPluginDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHelmPluginDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HelmPluginPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetHelmPluginVersionDetailsResponse parses an HTTP response from a GetHelmPluginVersionDetailsWithResponse call
func ParseGetHelmPluginVersionDetailsResponse(rsp *http.Response) (*GetHelmPluginVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHelmPluginVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HelmPluginPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetHelmPackageDetailsResponse parses an HTTP response from a GetHelmPackageDetailsWithResponse call
func ParseGetHelmPackageDetailsResponse(rsp *http.Response) (*GetHelmPackageDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHelmPackageDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HelmPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetHelmPackageVersionDetailsResponse parses an HTTP response from a GetHelmPackageVersionDetailsWithResponse call
func ParseGetHelmPackageVersionDetailsResponse(rsp *http.Response) (*GetHelmPackageVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHelmPackageVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest HelmPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetKedaScalerDetailsResponse parses an HTTP response from a GetKedaScalerDetailsWithResponse call
func ParseGetKedaScalerDetailsResponse(rsp *http.Response) (*GetKedaScalerDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKedaScalerDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KedaScalerPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetKedaScalerVersionDetailsResponse parses an HTTP response from a GetKedaScalerVersionDetailsWithResponse call
func ParseGetKedaScalerVersionDetailsResponse(rsp *http.Response) (*GetKedaScalerVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKedaScalerVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KedaScalerPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetKeptnIntegrationsDetailsResponse parses an HTTP response from a GetKeptnIntegrationsDetailsWithResponse call
func ParseGetKeptnIntegrationsDetailsResponse(rsp *http.Response) (*GetKeptnIntegrationsDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeptnIntegrationsDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeptnIntegrationsPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetKeptnIntegrationsVersionDetailsResponse parses an HTTP response from a GetKeptnIntegrationsVersionDetailsWithResponse call
func ParseGetKeptnIntegrationsVersionDetailsResponse(rsp *http.Response) (*GetKeptnIntegrationsVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKeptnIntegrationsVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KeptnIntegrationsPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetKnativeClientPluginIntegrationsDetailsResponse parses an HTTP response from a GetKnativeClientPluginIntegrationsDetailsWithResponse call
func ParseGetKnativeClientPluginIntegrationsDetailsResponse(rsp *http.Response) (*GetKnativeClientPluginIntegrationsDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKnativeClientPluginIntegrationsDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KnativeClientPluginsPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetKnativeClientPluginsVersionDetailsResponse parses an HTTP response from a GetKnativeClientPluginsVersionDetailsWithResponse call
func ParseGetKnativeClientPluginsVersionDetailsResponse(rsp *http.Response) (*GetKnativeClientPluginsVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKnativeClientPluginsVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KnativeClientPluginsPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetKubectlPluginDetailsResponse parses an HTTP response from a GetKubectlPluginDetailsWithResponse call
func ParseGetKubectlPluginDetailsResponse(rsp *http.Response) (*GetKubectlPluginDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKubectlPluginDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KrewPluginsPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetKubectlPluginVersionDetailsResponse parses an HTTP response from a GetKubectlPluginVersionDetailsWithResponse call
func ParseGetKubectlPluginVersionDetailsResponse(rsp *http.Response) (*GetKubectlPluginVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKubectlPluginVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KrewPluginsPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetKubeArmorPoliciesDetailsResponse parses an HTTP response from a GetKubeArmorPoliciesDetailsWithResponse call
func ParseGetKubeArmorPoliciesDetailsResponse(rsp *http.Response) (*GetKubeArmorPoliciesDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKubeArmorPoliciesDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KubeArmorPoliciesPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetKubeArmorPoliciesVersionDetailsResponse parses an HTTP response from a GetKubeArmorPoliciesVersionDetailsWithResponse call
func ParseGetKubeArmorPoliciesVersionDetailsResponse(rsp *http.Response) (*GetKubeArmorPoliciesVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKubeArmorPoliciesVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KubeArmorPoliciesPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetKubewardenPoliciesDetailsResponse parses an HTTP response from a GetKubewardenPoliciesDetailsWithResponse call
func ParseGetKubewardenPoliciesDetailsResponse(rsp *http.Response) (*GetKubewardenPoliciesDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKubewardenPoliciesDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KubewardenPoliciesPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetKubewardenPoliciesVersionDetailsResponse parses an HTTP response from a GetKubewardenPoliciesVersionDetailsWithResponse call
func ParseGetKubewardenPoliciesVersionDetailsResponse(rsp *http.Response) (*GetKubewardenPoliciesVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKubewardenPoliciesVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KubewardenPoliciesPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetKyvernoPoliciesDetailsResponse parses an HTTP response from a GetKyvernoPoliciesDetailsWithResponse call
func ParseGetKyvernoPoliciesDetailsResponse(rsp *http.Response) (*GetKyvernoPoliciesDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKyvernoPoliciesDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KyvernoPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetKyvernoPoliciesVersionDetailsResponse parses an HTTP response from a GetKyvernoPoliciesVersionDetailsWithResponse call
func ParseGetKyvernoPoliciesVersionDetailsResponse(rsp *http.Response) (*GetKyvernoPoliciesVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetKyvernoPoliciesVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest KyvernoPolicy
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOLMOperatorDetailsResponse parses an HTTP response from a GetOLMOperatorDetailsWithResponse call
func ParseGetOLMOperatorDetailsResponse(rsp *http.Response) (*GetOLMOperatorDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOLMOperatorDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OLMPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOLMOperatorVersionDetailsResponse parses an HTTP response from a GetOLMOperatorVersionDetailsWithResponse call
func ParseGetOLMOperatorVersionDetailsResponse(rsp *http.Response) (*GetOLMOperatorVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOLMOperatorVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OLMPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOPAPoliciesDetailsResponse parses an HTTP response from a GetOPAPoliciesDetailsWithResponse call
func ParseGetOPAPoliciesDetailsResponse(rsp *http.Response) (*GetOPAPoliciesDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOPAPoliciesDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OPAPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOPAPoliciesVersionDetailsResponse parses an HTTP response from a GetOPAPoliciesVersionDetailsWithResponse call
func ParseGetOPAPoliciesVersionDetailsResponse(rsp *http.Response) (*GetOPAPoliciesVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOPAPoliciesVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest OPAPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetRandomPackagesResponse parses an HTTP response from a GetRandomPackagesWithResponse call
func ParseGetRandomPackagesResponse(rsp *http.Response) (*GetRandomPackagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRandomPackagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PackageSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchPackagesResponse parses an HTTP response from a SearchPackagesWithResponse call
func ParseSearchPackagesResponse(rsp *http.Response) (*SearchPackagesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchPackagesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Facets   *[]Facets         `json:"facets,omitempty"`
			Packages *[]PackageSummary `json:"packages,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetStarredPackagesByUserResponse parses an HTTP response from a GetStarredPackagesByUserWithResponse call
func ParseGetStarredPackagesByUserResponse(rsp *http.Response) (*GetStarredPackagesByUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStarredPackagesByUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []PackageSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPackageStatsResponse parses an HTTP response from a GetPackageStatsWithResponse call
func ParseGetPackageStatsResponse(rsp *http.Response) (*GetPackageStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackageStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Packages *int `json:"packages,omitempty"`
			Releases *int `json:"releases,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTinkerbellActionsDetailsResponse parses an HTTP response from a GetTinkerbellActionsDetailsWithResponse call
func ParseGetTinkerbellActionsDetailsResponse(rsp *http.Response) (*GetTinkerbellActionsDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTinkerbellActionsDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TBActionPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTinkerbellActionsVersionDetailsResponse parses an HTTP response from a GetTinkerbellActionsVersionDetailsWithResponse call
func ParseGetTinkerbellActionsVersionDetailsResponse(rsp *http.Response) (*GetTinkerbellActionsVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTinkerbellActionsVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TBActionPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTektonPipelineDetailsResponse parses an HTTP response from a GetTektonPipelineDetailsWithResponse call
func ParseGetTektonPipelineDetailsResponse(rsp *http.Response) (*GetTektonPipelineDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTektonPipelineDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TektonPipelinePackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTektonPipelineVersionDetailsResponse parses an HTTP response from a GetTektonPipelineVersionDetailsWithResponse call
func ParseGetTektonPipelineVersionDetailsResponse(rsp *http.Response) (*GetTektonPipelineVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTektonPipelineVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TektonPipelinePackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTektonTaskDetailsResponse parses an HTTP response from a GetTektonTaskDetailsWithResponse call
func ParseGetTektonTaskDetailsResponse(rsp *http.Response) (*GetTektonTaskDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTektonTaskDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TektonTaskPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetTektonTaskVersionDetailsResponse parses an HTTP response from a GetTektonTaskVersionDetailsWithResponse call
func ParseGetTektonTaskVersionDetailsResponse(rsp *http.Response) (*GetTektonTaskVersionDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTektonTaskVersionDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TektonTaskPackage
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPackageChangelogResponse parses an HTTP response from a GetPackageChangelogWithResponse call
func ParseGetPackageChangelogResponse(rsp *http.Response) (*GetPackageChangelogResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackageChangelogResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			Changes *[]struct {
				Description string `json:"description"`

				// Kind Types of changes:
				//   * `added` - New features
				//   * `changed` - Changes in existing functionality
				//   * `deprecated` - Soon-to-be removed features
				//   * `removed` - Removed features
				//   * `fixed` - Any bug fixed
				//   * `security` - In case of vulnerabilities
				Kind  *ChangelogItemKind `json:"kind,omitempty"`
				Links *[]struct {
					Name string `json:"name"`
					Url  string `json:"url"`
				} `json:"links,omitempty"`
			} `json:"changes,omitempty"`
			ContainsSecurityUpdates bool   `json:"contains_security_updates"`
			Prerelease              bool   `json:"prerelease"`
			Ts                      int    `json:"ts"`
			Version                 string `json:"version"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPackageStarsResponse parses an HTTP response from a GetPackageStarsWithResponse call
func ParseGetPackageStarsResponse(rsp *http.Response) (*GetPackageStarsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackageStarsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			StarredByUser *bool `json:"starred_by_user,omitempty"`
			Stars         *int  `json:"stars,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTogglePackageStarResponse parses an HTTP response from a TogglePackageStarWithResponse call
func ParseTogglePackageStarResponse(rsp *http.Response) (*TogglePackageStarResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TogglePackageStarResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPackageViewsResponse parses an HTTP response from a GetPackageViewsWithResponse call
func ParseGetPackageViewsResponse(rsp *http.Response) (*GetPackageViewsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackageViewsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPackageSecurityReportResponse parses an HTTP response from a GetPackageSecurityReportWithResponse call
func ParseGetPackageSecurityReportResponse(rsp *http.Response) (*GetPackageSecurityReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackageSecurityReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetHelmChartTemplatesResponse parses an HTTP response from a GetHelmChartTemplatesWithResponse call
func ParseGetHelmChartTemplatesResponse(rsp *http.Response) (*GetHelmChartTemplatesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetHelmChartTemplatesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Templates []struct {
				Data []byte `json:"data"`
				Name string `json:"name"`
			} `json:"templates"`
			Values map[string]interface{} `json:"values"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetChartValuesResponse parses an HTTP response from a GetChartValuesWithResponse call
func ParseGetChartValuesResponse(rsp *http.Response) (*GetChartValuesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChartValuesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "yaml") && rsp.StatusCode == 200:
		var dest string
		if err := yaml.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.YAML200 = &dest

	}

	return response, nil
}

// ParseGetPackageValuesSchemaResponse parses an HTTP response from a GetPackageValuesSchemaWithResponse call
func ParseGetPackageValuesSchemaResponse(rsp *http.Response) (*GetPackageValuesSchemaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackageValuesSchemaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGenerateChangelogMDResponse parses an HTTP response from a GenerateChangelogMDWithResponse call
func ParseGenerateChangelogMDResponse(rsp *http.Response) (*GenerateChangelogMDResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GenerateChangelogMDResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetProductionUsageResponse parses an HTTP response from a GetProductionUsageWithResponse call
func ParseGetProductionUsageResponse(rsp *http.Response) (*GetProductionUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetProductionUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteProductionUsageResponse parses an HTTP response from a DeleteProductionUsageWithResponse call
func ParseDeleteProductionUsageResponse(rsp *http.Response) (*DeleteProductionUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteProductionUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddProductionUsageResponse parses an HTTP response from a AddProductionUsageWithResponse call
func ParseAddProductionUsageResponse(rsp *http.Response) (*AddProductionUsageResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddProductionUsageResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPackageSummaryResponse parses an HTTP response from a GetPackageSummaryWithResponse call
func ParseGetPackageSummaryResponse(rsp *http.Response) (*GetPackageSummaryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackageSummaryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PackageSummary
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFoundResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddOrganizationRepositoryResponse parses an HTTP response from a AddOrganizationRepositoryWithResponse call
func ParseAddOrganizationRepositoryResponse(rsp *http.Response) (*AddOrganizationRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOrganizationRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteOrganizationRepositoryResponse parses an HTTP response from a DeleteOrganizationRepositoryWithResponse call
func ParseDeleteOrganizationRepositoryResponse(rsp *http.Response) (*DeleteOrganizationRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrganizationRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateOrganizationRepositoryResponse parses an HTTP response from a UpdateOrganizationRepositoryWithResponse call
func ParseUpdateOrganizationRepositoryResponse(rsp *http.Response) (*UpdateOrganizationRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOrganizationRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseClaimRepositoryOwnershipFromOrganizationResponse parses an HTTP response from a ClaimRepositoryOwnershipFromOrganizationWithResponse call
func ParseClaimRepositoryOwnershipFromOrganizationResponse(rsp *http.Response) (*ClaimRepositoryOwnershipFromOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClaimRepositoryOwnershipFromOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTransferRepositoryOwnershipResponse parses an HTTP response from a TransferRepositoryOwnershipWithResponse call
func ParseTransferRepositoryOwnershipResponse(rsp *http.Response) (*TransferRepositoryOwnershipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferRepositoryOwnershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSearchRepositoriesResponse parses an HTTP response from a SearchRepositoriesWithResponse call
func ParseSearchRepositoriesResponse(rsp *http.Response) (*SearchRepositoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchRepositoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Repository
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddUserRepositoryResponse parses an HTTP response from a AddUserRepositoryWithResponse call
func ParseAddUserRepositoryResponse(rsp *http.Response) (*AddUserRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUserRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserRepositoryResponse parses an HTTP response from a DeleteUserRepositoryWithResponse call
func ParseDeleteUserRepositoryResponse(rsp *http.Response) (*DeleteUserRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserRepositoryResponse parses an HTTP response from a UpdateUserRepositoryWithResponse call
func ParseUpdateUserRepositoryResponse(rsp *http.Response) (*UpdateUserRepositoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserRepositoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseClaimRepositoryOwnershipResponse parses an HTTP response from a ClaimRepositoryOwnershipWithResponse call
func ParseClaimRepositoryOwnershipResponse(rsp *http.Response) (*ClaimRepositoryOwnershipResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ClaimRepositoryOwnershipResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTransferRepositoryOwnershipToOrganizationResponse parses an HTTP response from a TransferRepositoryOwnershipToOrganizationWithResponse call
func ParseTransferRepositoryOwnershipToOrganizationResponse(rsp *http.Response) (*TransferRepositoryOwnershipToOrganizationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TransferRepositoryOwnershipToOrganizationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetArtifactHubStatsResponse parses an HTTP response from a GetArtifactHubStatsWithResponse call
func ParseGetArtifactHubStatsResponse(rsp *http.Response) (*GetArtifactHubStatsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetArtifactHubStatsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			GeneratedAt   int `json:"generated_at"`
			Organizations struct {
				RunningTotal *[][]int `json:"running_total,omitempty"`
				Total        int      `json:"total"`
			} `json:"organizations"`
			Packages struct {
				CreatedMonthly *[][]int `json:"created_monthly,omitempty"`
				RunningTotal   *[][]int `json:"running_total,omitempty"`
				Total          int      `json:"total"`
				ViewsDaily     *[][]int `json:"views_daily,omitempty"`
			} `json:"packages"`
			Repositories struct {
				CreatedMonthly *[][]int `json:"created_monthly,omitempty"`
				RunningTotal   *[][]int `json:"running_total,omitempty"`
				Total          int      `json:"total"`
			} `json:"repositories"`
			Snapshots struct {
				CreatedMonthly *[][]int `json:"created_monthly,omitempty"`
				RunningTotal   *[][]int `json:"running_total,omitempty"`
				Total          int      `json:"total"`
			} `json:"snapshots"`
			Users struct {
				RunningTotal *[][]int `json:"running_total,omitempty"`
				Total        int      `json:"total"`
			} `json:"users"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeletePackageSubscriptionResponse parses an HTTP response from a DeletePackageSubscriptionWithResponse call
func ParseDeletePackageSubscriptionResponse(rsp *http.Response) (*DeletePackageSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePackageSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserSubscriptionsResponse parses an HTTP response from a GetUserSubscriptionsWithResponse call
func ParseGetUserSubscriptionsResponse(rsp *http.Response) (*GetUserSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			EventKinds     []EventKindId      `json:"event_kinds"`
			LogoImageId    *string            `json:"logo_image_id,omitempty"`
			Name           string             `json:"name"`
			NormalizedName string             `json:"normalized_name"`
			PackageId      openapi_types.UUID `json:"package_id"`
			Repository     RepositorySummary  `json:"repository"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddPackageSubscriptionResponse parses an HTTP response from a AddPackageSubscriptionWithResponse call
func ParseAddPackageSubscriptionResponse(rsp *http.Response) (*AddPackageSubscriptionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddPackageSubscriptionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserOptOutEntriesResponse parses an HTTP response from a GetUserOptOutEntriesWithResponse call
func ParseGetUserOptOutEntriesResponse(rsp *http.Response) (*GetUserOptOutEntriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserOptOutEntriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// EventKind Event kind:
			//   * `0` - New package release
			//   * `1` - Security alerts
			//   * `2` - Repository tracking errors
			//   * `4` - Repository scanning errors
			EventKind  EventKindId        `json:"event_kind"`
			OptOutId   openapi_types.UUID `json:"opt_out_id"`
			Repository RepositorySummary  `json:"repository"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddOptOutEntryResponse parses an HTTP response from a AddOptOutEntryWithResponse call
func ParseAddOptOutEntryResponse(rsp *http.Response) (*AddOptOutEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOptOutEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteOptOutEntryResponse parses an HTTP response from a DeleteOptOutEntryWithResponse call
func ParseDeleteOptOutEntryResponse(rsp *http.Response) (*DeleteOptOutEntryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOptOutEntryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetPackageUserSubscriptionsResponse parses an HTTP response from a GetPackageUserSubscriptionsWithResponse call
func ParseGetPackageUserSubscriptionsResponse(rsp *http.Response) (*GetPackageUserSubscriptionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPackageUserSubscriptionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []struct {
			// EventKind Event kind:
			//   * `0` - New package release
			//   * `1` - Security alerts
			//   * `2` - Repository tracking errors
			//   * `4` - Repository scanning errors
			EventKind EventKindId `json:"event_kind"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseRegisterUserResponse parses an HTTP response from a RegisterUserWithResponse call
func ParseRegisterUserResponse(rsp *http.Response) (*RegisterUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RegisterUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserPasswordResponse parses an HTTP response from a UpdateUserPasswordWithResponse call
func ParseUpdateUserPasswordResponse(rsp *http.Response) (*UpdateUserPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseResetPasswordCodeResponse parses an HTTP response from a ResetPasswordCodeWithResponse call
func ParseResetPasswordCodeResponse(rsp *http.Response) (*ResetPasswordCodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetPasswordCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserProfileResponse parses an HTTP response from a GetUserProfileWithResponse call
func ParseGetUserProfileResponse(rsp *http.Response) (*GetUserProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserProfileResponse parses an HTTP response from a UpdateUserProfileWithResponse call
func ParseUpdateUserProfileResponse(rsp *http.Response) (*UpdateUserProfileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserProfileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseResetPasswordResponse parses an HTTP response from a ResetPasswordWithResponse call
func ParseResetPasswordResponse(rsp *http.Response) (*ResetPasswordResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResetPasswordResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseVerifyEmailResponse parses an HTTP response from a VerifyEmailWithResponse call
func ParseVerifyEmailResponse(rsp *http.Response) (*VerifyEmailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VerifyEmailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseVerifyPasswordCodeResponse parses an HTTP response from a VerifyPasswordCodeWithResponse call
func ParseVerifyPasswordCodeResponse(rsp *http.Response) (*VerifyPasswordCodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &VerifyPasswordCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrganizationWebhooksResponse parses an HTTP response from a GetOrganizationWebhooksWithResponse call
func ParseGetOrganizationWebhooksResponse(rsp *http.Response) (*GetOrganizationWebhooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationWebhooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Webhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddOrganizationWebhookResponse parses an HTTP response from a AddOrganizationWebhookWithResponse call
func ParseAddOrganizationWebhookResponse(rsp *http.Response) (*AddOrganizationWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddOrganizationWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteOrganizationWebhookResponse parses an HTTP response from a DeleteOrganizationWebhookWithResponse call
func ParseDeleteOrganizationWebhookResponse(rsp *http.Response) (*DeleteOrganizationWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteOrganizationWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetOrganizationWebhookDetailsResponse parses an HTTP response from a GetOrganizationWebhookDetailsWithResponse call
func ParseGetOrganizationWebhookDetailsResponse(rsp *http.Response) (*GetOrganizationWebhookDetailsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetOrganizationWebhookDetailsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Webhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateOrganizationWebhookResponse parses an HTTP response from a UpdateOrganizationWebhookWithResponse call
func ParseUpdateOrganizationWebhookResponse(rsp *http.Response) (*UpdateOrganizationWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateOrganizationWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest Forbidden
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseTriggerWebhookTestResponse parses an HTTP response from a TriggerWebhookTestWithResponse call
func ParseTriggerWebhookTestResponse(rsp *http.Response) (*TriggerWebhookTestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TriggerWebhookTestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserWebhooksResponse parses an HTTP response from a GetUserWebhooksWithResponse call
func ParseGetUserWebhooksResponse(rsp *http.Response) (*GetUserWebhooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserWebhooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []Webhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseAddUserWebhookResponse parses an HTTP response from a AddUserWebhookWithResponse call
func ParseAddUserWebhookResponse(rsp *http.Response) (*AddUserWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddUserWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteUserWebhookResponse parses an HTTP response from a DeleteUserWebhookWithResponse call
func ParseDeleteUserWebhookResponse(rsp *http.Response) (*DeleteUserWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetUserWebhookDetailResponse parses an HTTP response from a GetUserWebhookDetailWithResponse call
func ParseGetUserWebhookDetailResponse(rsp *http.Response) (*GetUserWebhookDetailResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserWebhookDetailResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Webhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateUserWebhookResponse parses an HTTP response from a UpdateUserWebhookWithResponse call
func ParseUpdateUserWebhookResponse(rsp *http.Response) (*UpdateUserWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateUserWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest UnauthorizedError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
